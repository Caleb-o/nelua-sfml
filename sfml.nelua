global sfml = @record{}

##[[
  cinclude "SFML/Config.h"
  cinclude "SFML/GPUPreference.h"
  cinclude "SFML/System.h"
  cinclude "SFML/Audio.h"
  cinclude "SFML/Network.h"
  cinclude "SFML/Window.h"
  cinclude "SFML/Graphics.h"
  
  linklib "csfml-audio"
  linklib "csfml-graphics"
  linklib "csfml-network"
  linklib "csfml-system"
  linklib "csfml-window"
]]

-- Global Information
global CSFML_VERSION_MAJOR: cint <cimport, nodecl, const>
global CSFML_VERSION_MINOR: cint <cimport, nodecl, const>
global CSFML_VERSION_PATCH: cint <cimport, nodecl, const>
global CSFML_SYSTEM_WINDOWS: cint <cimport, nodecl, const>
global CSFML_SYSTEM_LINUX: cint <cimport, nodecl, const>
global CSFML_SYSTEM_MACOS: cint <cimport, nodecl, const>
global CSFML_SYSTEM_FREEBSD: cint <cimport, nodecl, const>


-- Types
global sfBool: type <cimport, nodecl> = @cint
global sfFalse: cint <cimport, nodecl, const>
global sfTrue: cint <cimport, nodecl, const>

global sfInt8: type <cimport, nodecl> = @cchar
global sfUint8: type <cimport, nodecl> = @cuchar
global sfInt16: type <cimport, nodecl> = @cshort
global sfUint16: type <cimport, nodecl> = @cushort
global sfInt32: type <cimport, nodecl> = @cint
global sfUint32: type <cimport, nodecl> = @cuint
global sfInt64: type <cimport, nodecl> = @clonglong
global sfUint64: type <cimport, nodecl> = @culonglong


-- Time
global sfml.Time: type <cimport 'sfTime', nodecl> = @record {
  microseconds: sfInt64
}

global sfml.Time.zero: sfml.Time <cimport 'sfTime_Zero', nodecl, const>

function sfml.Time.asSeconds(self: sfml.Time): float32 <cimport 'sfTime_asSeconds', nodecl> end
function sfml.Time.asMilliseconds(self: sfml.Time): sfInt32 <cimport 'sfTime_asMilliseconds', nodecl> end
function sfml.Time.asMicroseconds(self: sfml.Time): sfInt64 <cimport 'sfTime_asMicroseconds', nodecl> end

function sfml.Time.Seconds(amount: float32): sfml.Time <cimport 'sfSeconds', nodecl> end
function sfml.Time.milliseconds(amount: sfInt32): sfml.Time <cimport 'sfMilliseconds', nodecl> end
function sfml.Time.microseconds(amount: sfInt64): sfml.Time <cimport 'sfMicroseconds', nodecl> end


-- Clock
global sfml.Clock: type <cimport 'sfClock', nodecl, forwarddecl> = @record {}

function sfml.Clock.create(): *sfml.Clock <cimport 'sfClock_create', nodecl> end
function sfml.Clock.copy(self: *sfml.Clock <const>): *sfml.Clock <cimport 'sfClock_copy', nodecl> end
function sfml.Clock.destroy(self: *sfml.Clock): void <cimport 'sfClock_destroy', nodecl> end
function sfml.Clock.getElapsedTime(self: *sfml.Clock <const>): sfml.Time <cimport 'sfClock_getElapsedTime', nodecl> end
function sfml.Clock.restart(self: *sfml.Clock): sfml.Time <cimport 'sfClock_restart', nodecl> end


-- InputStream
global sfml.InputStreamReadFunc: type <cimport 'sfInputStreamReadFunc', nodecl> = @function(pointer, sfInt64, pointer): sfInt64
global sfml.InputStreamSeekFunc: type <cimport 'sfInputStreamSeekFunc', nodecl> = @function(sfInt64, pointer): sfInt64
global sfml.InputStreamTellFunc: type <cimport 'sfInputStreamTellFunc', nodecl> = @function(pointer): sfInt64
global sfml.InputStreamGetSizeFunc: type <cimport 'sfInputStreamGetSizeFunc', nodecl> = @function(pointer): sfInt64

global sfml.InputStream: type <cimport 'sfInputStream', nodecl> = @record {
  read: sfml.InputStreamReadFunc,
  seek: sfml.InputStreamSeekFunc,
  tell: sfml.InputStreamTellFunc,
  getSize: sfml.InputStreamGetSizeFunc,
  userData: pointer
}

-- Mutex
global sfml.Mutex: type <cimport 'sfMutex', nodecl, forwarddecl> = @record {}

function sfml.Mutex.create(): *sfml.Mutex <cimport 'sfMutex_create', nodecl> end
function sfml.Mutex.destroy(self: *sfml.Mutex): void <cimport 'sfMutex_destroy', nodecl> end
function sfml.Mutex.lock(self: *sfml.Mutex): void <cimport 'sfMutex_lock', nodecl> end
function sfml.Mutex.unlock(self: *sfml.Mutex): void <cimport 'sfMutex_unlock', nodecl> end

function sfml.Time.Sleep(duration: sfml.Time): void <cimport 'sfSleep', nodecl> end

-- Thread
global sfml.Thread: type <cimport 'sfThread', nodecl, forwarddecl> = @record {}

function sfml.Thread.create(f: function(pointer): void, userdata: pointer): *sfml.Thread <cimport 'sfThread_create', nodecl> end
function sfml.Thread.destroy(self: *sfml.Thread): void <cimport 'sfThread_destroy', nodecl> end
function sfml.Thread.launch(self: *sfml.Thread): void <cimport 'sfThread_launch', nodecl> end
function sfml.Thread.wait(self: *sfml.Thread): void <cimport 'sfThread_wait', nodecl> end
function sfml.Thread.terminate(self: *sfml.Thread): void <cimport 'sfThread_terminate', nodecl> end


-- Vector
global sfml.Vector2i: type <cimport 'sfVector2i', nodecl> = @record {
  x: cint,
  y: cint
}

global sfml.Vector2u: type <cimport 'sfVector2u', nodecl> = @record {
  x: cuint,
  y: cuint
}

global sfml.Vector2f: type <cimport 'sfVector2f', nodecl> = @record {
  x: float32,
  y: float32
}

global sfml.Vector3f: type <cimport 'sfVector3f', nodecl> = @record {
  x: float32,
  y: float32,
  z: float32
}


-- Network
global sfml.FtpDirectoryResponse: type <cimport 'sfFtpDirectoryResponse', nodecl, forwarddecl> = @record {}
global sfml.FtpListingResponse: type <cimport 'sfFtpListingResponse', nodecl, forwarddecl> = @record {}
global sfml.FtpResponse: type <cimport 'sfFtpResponse', nodecl, forwarddecl> = @record {}
global sfml.Ftp: type <cimport 'sfFtp', nodecl, forwarddecl> = @record {}
global sfml.HttpRequest: type <cimport 'sfml.HttpRequest', nodecl, forwarddecl> = @record {}
global sfml.HttpResponse: type <cimport 'sfml.HttpResponse', nodecl, forwarddecl> = @record {}
global sfml.Http: type <cimport 'sfml.Http', nodecl, forwarddecl> = @record {}
global sfml.Packet: type <cimport 'sfPacket', nodecl, forwarddecl> = @record {}
global sfml.SocketSelector: type <cimport 'sfSocketSelector', nodecl, forwarddecl> = @record {}
global sfml.TcpListener: type <cimport 'sfTcpListener', nodecl, forwarddecl> = @record {}
global sfml.TcpSocket: type <cimport 'sfTcpSocket', nodecl, forwarddecl> = @record {}
global sfml.UdpSocket: type <cimport 'sfUdpSocket', nodecl, forwarddecl> = @record {}


-- Network: IpAddress
global sfml.IpAddress: type <cimport 'sfIpAddress', nodecl> = @record {
  address: [16]cchar
}

global sfml.IpAddress.None: sfml.IpAddress <cimport 'sfIpAddress_None', nodecl, const>
global sfml.IpAddress.Any: sfml.IpAddress <cimport 'sfIpAddress_Any', nodecl, const>
global sfml.IpAddress.LocalHost: sfml.IpAddress <cimport 'sfIpAddress_LocalHost', nodecl, const>
global sfml.IpAddress.Broadcast: sfml.IpAddress <cimport 'sfIpAddress_Broadcast', nodecl, const>

function sfml.IpAddress.fromString(address: cstring <const>): sfml.IpAddress <cimport 'sfIpAddress_fromString', nodecl> end
function sfml.IpAddress.fromBytes(byte0: sfUint8, byte1: sfUint8, byte2: sfUint8, byte3: sfUint8): sfml.IpAddress <cimport 'sfIpAddress_fromBytes', nodecl> end
function sfml.IpAddress.fromInteger(address: sfUint32): sfml.IpAddress <cimport 'sfIpAddress_fromInteger', nodecl> end
function sfml.IpAddress.toString(self: sfml.IpAddress, string: cstring): void <cimport 'sfIpAddress_toString', nodecl> end
function sfml.IpAddress.toInteger(self: sfml.IpAddress): sfUint32 <cimport 'sfIpAddress_toInteger', nodecl> end
function sfml.IpAddress.getLocalAddress(): sfml.IpAddress <cimport 'sfIpAddress_getLocalAddress', nodecl> end
function sfml.IpAddress.getPublicAddress(timeout: sfml.Time): sfml.IpAddress <cimport 'sfIpAddress_getPublicAddress', nodecl> end

-- Network: FTP
global sfml.FtpTransferMode: type <cimport 'sfFtpTransferMode', nodecl, using> = @enum(cint) {
  FtpBinary = 0,
  FtpAscii,
  FtpEbcdic
}

global sfml.FtpStatus: type <cimport 'sfFtpStatus', nodecl, using> = @enum(cint) {
  FtpRestartMarkerReply          = 110,
  FtpServiceReadySoon            = 120,
  FtpDataConnectionAlreadyOpened = 125,
  FtpOpeningDataConnection       = 150,  
  FtpOk                    = 200,
  FtpPointlessCommand      = 202,
  FtpSystemStatus          = 211,
  FtpDirectoryStatus       = 212,
  FtpFileStatus            = 213,
  FtpHelpMessage           = 214,
  FtpSystemType            = 215,
  FtpServiceReady          = 220,
  FtpClosingConnection     = 221,
  FtpDataConnectionOpened  = 225,
  FtpClosingDataConnection = 226,
  FtpEnteringPassiveMode   = 227,
  FtpLoggedIn              = 230,
  FtpFileActionOk          = 250,
  FtpDirectoryOk           = 257,
  FtpNeedPassword       = 331,
  FtpNeedAccountToLogIn = 332,
  FtpNeedInformation    = 350,

  FtpServiceUnavailable        = 421,
  FtpDataConnectionUnavailable = 425,
  FtpTransferAborted           = 426,
  FtpFileActionAborted         = 450,
  FtpLocalError                = 451,
  FtpInsufficientStorageSpace  = 452,
  FtpCommandUnknown          = 500,
  FtpParametersUnknown       = 501,
  FtpCommandNotImplemented   = 502,
  FtpBadCommandSequence      = 503,
  FtpParameterNotImplemented = 504,
  FtpNotLoggedIn             = 530,
  FtpNeedAccountToStore      = 532,
  FtpFileUnavailable         = 550,
  FtpPageTypeUnknown         = 551,
  FtpNotEnoughMemory         = 552,
  FtpFilenameNotAllowed      = 553,
  FtpInvalidResponse  = 1000,
  FtpConnectionFailed = 1001,
  FtpConnectionClosed = 1002,
  FtpInvalidFile      = 1003
}

function sfml.FtpListingResponse.destroy(self: *sfml.FtpListingResponse): void <cimport 'sfFtpListingResponse_destroy', nodecl> end
function sfml.FtpListingResponse.isOk(self: *sfml.FtpListingResponse <const>): sfBool <cimport 'sfFtpListingResponse_isOk', nodecl> end
function sfml.FtpListingResponse.getStatus(self: *sfml.FtpListingResponse <const>): sfml.FtpStatus <cimport 'sfFtpListingResponse_getStatus', nodecl> end
function sfml.FtpListingResponse.getMessage(self: *sfml.FtpListingResponse <const>): cstring <cimport 'sfFtpListingResponse_getMessage', nodecl> end
function sfml.FtpListingResponse.getCount(self: *sfml.FtpListingResponse <const>): csize <cimport 'sfFtpListingResponse_getCount', nodecl> end
function sfml.FtpListingResponse.getName(self: *sfml.FtpListingResponse <const>, index: csize): cstring <cimport 'sfFtpListingResponse_getName', nodecl> end

function sfml.FtpDirectoryResponse.destroy(self: *sfml.FtpListingResponse): void <cimport 'sfFtpDirectoryResponse_destroy', nodecl> end
function sfml.FtpDirectoryResponse.isOk(self: *sfml.FtpListingResponse <const>): sfBool <cimport 'sfFtpDirectoryResponse_isOk', nodecl> end
function sfml.FtpDirectoryResponse.getStatus(self: *sfml.FtpListingResponse <const>): sfml.FtpStatus <cimport 'sfFtpDirectoryResponse_getStatus', nodecl> end
function sfml.FtpDirectoryResponse.getMessage(self: *sfml.FtpListingResponse <const>): cstring <cimport 'sfFtpDirectoryResponse_getMessage', nodecl> end
function sfml.FtpDirectoryResponse.getDirectory(self: *sfml.FtpListingResponse <const>): cstring <cimport 'sfFtpDirectoryResponse_getDirectory', nodecl> end

function sfml.FtpResponse.destroy(self: *sfml.FtpResponse): void <cimport 'sfFtpResponse_destroy', nodecl> end
function sfml.FtpResponse.isOk(self: *sfml.FtpResponse <const>): sfBool <cimport 'sfFtpResponse_isOk', nodecl> end
function sfml.FtpResponse.getStatus(self: *sfml.FtpResponse <const>): sfml.FtpStatus <cimport 'sfFtpResponse_getStatus', nodecl> end
function sfml.FtpResponse.getMessage(self: *sfml.FtpResponse <const>): cstring <cimport 'sfFtpResponse_getMessage', nodecl> end

function sfml.Ftp.create(): *sfml.Ftp <cimport 'sfFtp_create', nodecl> end
function sfml.Ftp.destroy(self: *sfml.Ftp): void <cimport 'sfFtp_destroy', nodecl> end
function sfml.Ftp.connect(self: *sfml.Ftp, server: sfml.IpAddress, port: cushort, timeout: sfml.Time): *sfml.FtpResponse <cimport 'sfFtp_connect', nodecl> end
function sfml.Ftp.loginAnonymous(self: *sfml.Ftp): *sfml.FtpResponse <cimport 'sfFtp_loginAnonymous', nodecl> end
function sfml.Ftp.login(self: *sfml.Ftp, name: cstring <const>, password: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_login', nodecl> end
function sfml.Ftp.disconnect(self: *sfml.Ftp): *sfml.FtpResponse <cimport 'sfFtp_disconnect', nodecl> end
function sfml.Ftp.keepAlive(self: *sfml.Ftp): *sfml.FtpResponse <cimport 'sfFtp_keepAlive', nodecl> end
function sfml.Ftp.getWorkingDirectory(self: *sfml.Ftp): *sfml.FtpDirectoryResponse <cimport 'sfFtp_getWorkingDirectory', nodecl> end
function sfml.Ftp.getDirectoryListing(self: *sfml.Ftp, directory: cstring <const>): *sfml.FtpListingResponse <cimport 'sfFtp_getDirectoryListing', nodecl> end
function sfml.Ftp.changeDirectory(self: *sfml.Ftp, directory: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_changeDirectory', nodecl> end
function sfml.Ftp.parentDirectory(self: *sfml.Ftp): *sfml.FtpResponse <cimport 'sfFtp_parentDirectory', nodecl> end
function sfml.Ftp.createDirectory(self: *sfml.Ftp, name: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_createDirectory', nodecl> end
function sfml.Ftp.deleteDirectory(self: *sfml.Ftp, name: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_deleteDirectory', nodecl> end
function sfml.Ftp.renameFile(self: *sfml.Ftp, file: cstring <const>, newName: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_renameFile', nodecl> end
function sfml.Ftp.deleteFile(self: *sfml.Ftp, file: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_deleteFile', nodecl> end
function sfml.Ftp.download(self: *sfml.Ftp, remoteFile: cstring <const>, localPath: cstring <const>, mode: sfml.FtpTransferMode): *sfml.FtpResponse <cimport 'sfFtp_download', nodecl> end
function sfml.Ftp.upload(self: *sfml.Ftp, localFile: cstring <const>, remotePath: cstring <const>, mode: sfml.FtpTransferMode, append: sfBool): *sfml.FtpResponse <cimport 'sfFtp_upload', nodecl> end
function sfml.Ftp.sendCommand(self: *sfml.Ftp, command: cstring <const>, parameter: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_sendCommand', nodecl> end


-- Network: HTTP
global sfml.HttpMethod: type <cimport 'sfml.HttpMethod', nodecl, using> = @enum(cint) {
  HttpGet = 0,
  HttpPost,
  HttpHead,
  HttpPut,
  HttpDelete
}

global sfml.HttpStatus: type <cimport 'sfHttpStatus', nodecl, using> = @enum(cint) {
  HttpOk             = 200,
  HttpCreated        = 201,
  HttpAccepted       = 202,
  HttpNoContent      = 204,
  HttpResetContent   = 205,
  HttpPartialContent = 206,

  HttpMultipleChoices  = 300,
  HttpMovedPermanently = 301,
  HttpMovedTemporarily = 302,
  HttpNotModified      = 304,

  HttpBadRequest          = 400,
  HttpUnauthorized        = 401,
  HttpForbidden           = 403,
  HttpNotFound            = 404,
  HttpRangeNotSatisfiable = 407,

  HttpInternalServerError = 500,
  HttpNotImplemented      = 501,
  HttpBadGateway          = 502,
  HttpServiceNotAvailable = 503,
  HttpGatewayTimeout      = 504,
  HttpVersionNotSupported = 505,

  HttpInvalidResponse  = 1000,
  HttpConnectionFailed = 1001
}

function sfml.HttpRequest.create(): *sfml.HttpRequest <cimport 'sfHttpRequest_create', nodecl> end
function sfml.HttpRequest.destroy(self: *sfml.HttpRequest): void <cimport 'sfHttpRequest_destroy', nodecl> end
function sfml.HttpRequest.setField(self: *sfml.HttpRequest, field: cstring <const>, value: cstring <const>): void <cimport 'sfHttpRequest_setField', nodecl> end
function sfml.HttpRequest.setMethod(self: *sfml.HttpRequest, method: sfml.HttpMethod): void <cimport 'sfHttpRequest_setMethod', nodecl> end
function sfml.HttpRequest.setUri(self: *sfml.HttpRequest, uri: cstring <const>): void <cimport 'sfHttpRequest_setUri', nodecl> end
function sfml.HttpRequest.setHttpVersion(self: *sfml.HttpRequest, major: cuint, minor: cuint): void <cimport 'sfHttpRequest_setHttpVersion', nodecl> end
function sfml.HttpRequest.setBody(self: *sfml.HttpRequest, body: cstring <const>): void <cimport 'sfHttpRequest_setBody', nodecl> end

function sfml.HttpResponse.destroy(self: *sfml.HttpResponse): void <cimport 'sfHttpResponse_destroy', nodecl> end
function sfml.HttpResponse.getField(self: *sfml.HttpResponse <const>, field: cstring <const>): cstring <cimport 'sfHttpResponse_getField', nodecl> end
function sfml.HttpResponse.getStatus(self: *sfml.HttpResponse <const>): sfml.HttpStatus <cimport 'sfHttpResponse_getStatus', nodecl> end
function sfml.HttpResponse.getMajorVersion(self: *sfml.HttpResponse <const>): cuint <cimport 'sfHttpResponse_getMajorVersion', nodecl> end
function sfml.HttpResponse.getMinorVersion(self: *sfml.HttpResponse <const>): cuint <cimport 'sfHttpResponse_getMinorVersion', nodecl> end
function sfml.HttpResponse.getBody(self: *sfml.HttpResponse <const>): cstring <cimport 'sfHttpResponse_getBody', nodecl> end

function sfml.Http.create(): *sfml.Http <cimport 'sfHttp_create', nodecl> end
function sfml.Http.destroy(http: *sfml.Http): void <cimport 'sfHttp_destroy', nodecl> end
function sfml.Http.setHost(http: *sfml.Http, host: cstring <const>, port: cuint): void <cimport 'sfHttp_setHost', nodecl> end
function sfml.Http.sendRequest(http: *sfml.Http, request: *sfml.HttpRequest <const>, timeout: sfml.Time): *sfml.HttpResponse <cimport 'sfHttp_sendRequest', nodecl> end