global sfml = @record{}

##[[
  cinclude "SFML/Config.h"
  cinclude "SFML/GPUPreference.h"
  cinclude "SFML/System.h"
  cinclude "SFML/Audio.h"
  cinclude "SFML/Network.h"
  cinclude "SFML/Window.h"
  cinclude "SFML/Graphics.h"
  
  linklib "csfml-audio"
  linklib "csfml-graphics"
  linklib "csfml-network"
  linklib "csfml-system"
  linklib "csfml-window"
]]

-- Global Information
global CSFML_VERSION_MAJOR: cint <cimport, nodecl, const>
global CSFML_VERSION_MINOR: cint <cimport, nodecl, const>
global CSFML_VERSION_PATCH: cint <cimport, nodecl, const>
global CSFML_SYSTEM_WINDOWS: cint <cimport, nodecl, const>
global CSFML_SYSTEM_LINUX: cint <cimport, nodecl, const>
global CSFML_SYSTEM_MACOS: cint <cimport, nodecl, const>
global CSFML_SYSTEM_FREEBSD: cint <cimport, nodecl, const>


-- Types
global sfBool: type <cimport, nodecl> = @cint
global sfFalse: cint <cimport, nodecl, const>
global sfTrue: cint <cimport, nodecl, const>

global sfInt8: type <cimport, nodecl> = @cchar
global sfUint8: type <cimport, nodecl> = @cuchar
global sfInt16: type <cimport, nodecl> = @cshort
global sfUint16: type <cimport, nodecl> = @cushort
global sfInt32: type <cimport, nodecl> = @cint
global sfUint32: type <cimport, nodecl> = @cuint
global sfInt64: type <cimport, nodecl> = @clonglong
global sfUint64: type <cimport, nodecl> = @culonglong


-- Time
global sfml.Time: type <cimport 'sfTime', nodecl> = @record {
  microseconds: sfInt64
}

global sfml.Time.zero: sfml.Time <cimport 'sfTime_Zero', nodecl, const>

function sfml.Time.asSeconds(self: sfml.Time): float32 <cimport 'sfTime_asSeconds', nodecl> end
function sfml.Time.asMilliseconds(self: sfml.Time): sfInt32 <cimport 'sfTime_asMilliseconds', nodecl> end
function sfml.Time.asMicroseconds(self: sfml.Time): sfInt64 <cimport 'sfTime_asMicroseconds', nodecl> end

function sfml.Time.Seconds(amount: float32): sfml.Time <cimport 'sfSeconds', nodecl> end
function sfml.Time.milliseconds(amount: sfInt32): sfml.Time <cimport 'sfMilliseconds', nodecl> end
function sfml.Time.microseconds(amount: sfInt64): sfml.Time <cimport 'sfMicroseconds', nodecl> end


-- Clock
global sfml.Clock: type <cimport 'sfClock', nodecl, forwarddecl> = @record {}

function sfml.Clock.create(): *sfml.Clock <cimport 'sfClock_create', nodecl> end
function sfml.Clock.copy(self: *sfml.Clock <const>): *sfml.Clock <cimport 'sfClock_copy', nodecl> end
function sfml.Clock.destroy(self: *sfml.Clock): void <cimport 'sfClock_destroy', nodecl> end
function sfml.Clock.getElapsedTime(self: *sfml.Clock <const>): sfml.Time <cimport 'sfClock_getElapsedTime', nodecl> end
function sfml.Clock.restart(self: *sfml.Clock): sfml.Time <cimport 'sfClock_restart', nodecl> end


-- InputStream
global sfml.InputStreamReadFunc: type <cimport 'sfInputStreamReadFunc', nodecl> = @function(pointer, sfInt64, pointer): sfInt64
global sfml.InputStreamSeekFunc: type <cimport 'sfInputStreamSeekFunc', nodecl> = @function(sfInt64, pointer): sfInt64
global sfml.InputStreamTellFunc: type <cimport 'sfInputStreamTellFunc', nodecl> = @function(pointer): sfInt64
global sfml.InputStreamGetSizeFunc: type <cimport 'sfInputStreamGetSizeFunc', nodecl> = @function(pointer): sfInt64

global sfml.InputStream: type <cimport 'sfInputStream', nodecl> = @record {
  read: sfml.InputStreamReadFunc,
  seek: sfml.InputStreamSeekFunc,
  tell: sfml.InputStreamTellFunc,
  getSize: sfml.InputStreamGetSizeFunc,
  userData: pointer
}

-- Mutex
global sfml.Mutex: type <cimport 'sfMutex', nodecl, forwarddecl> = @record {}

function sfml.Mutex.create(): *sfml.Mutex <cimport 'sfMutex_create', nodecl> end
function sfml.Mutex.destroy(self: *sfml.Mutex): void <cimport 'sfMutex_destroy', nodecl> end
function sfml.Mutex.lock(self: *sfml.Mutex): void <cimport 'sfMutex_lock', nodecl> end
function sfml.Mutex.unlock(self: *sfml.Mutex): void <cimport 'sfMutex_unlock', nodecl> end

function sfml.Time.Sleep(duration: sfml.Time): void <cimport 'sfSleep', nodecl> end

-- Thread
global sfml.Thread: type <cimport 'sfThread', nodecl, forwarddecl> = @record {}

function sfml.Thread.create(f: function(pointer): void, userdata: pointer): *sfml.Thread <cimport 'sfThread_create', nodecl> end
function sfml.Thread.destroy(self: *sfml.Thread): void <cimport 'sfThread_destroy', nodecl> end
function sfml.Thread.launch(self: *sfml.Thread): void <cimport 'sfThread_launch', nodecl> end
function sfml.Thread.wait(self: *sfml.Thread): void <cimport 'sfThread_wait', nodecl> end
function sfml.Thread.terminate(self: *sfml.Thread): void <cimport 'sfThread_terminate', nodecl> end


-- Vector
global sfml.Vector2i: type <cimport 'sfVector2i', nodecl> = @record {
  x: cint,
  y: cint
}

global sfml.Vector2u: type <cimport 'sfVector2u', nodecl> = @record {
  x: cuint,
  y: cuint
}

global sfml.Vector2f: type <cimport 'sfVector2f', nodecl> = @record {
  x: float32,
  y: float32
}

global sfml.Vector3f: type <cimport 'sfVector3f', nodecl> = @record {
  x: float32,
  y: float32,
  z: float32
}


-- Network
global sfml.FtpDirectoryResponse: type <cimport 'sfFtpDirectoryResponse', nodecl, forwarddecl> = @record {}
global sfml.FtpListingResponse: type <cimport 'sfFtpListingResponse', nodecl, forwarddecl> = @record {}
global sfml.FtpResponse: type <cimport 'sfFtpResponse', nodecl, forwarddecl> = @record {}
global sfml.Ftp: type <cimport 'sfFtp', nodecl, forwarddecl> = @record {}
global sfml.HttpRequest: type <cimport 'sfml.HttpRequest', nodecl, forwarddecl> = @record {}
global sfml.HttpResponse: type <cimport 'sfml.HttpResponse', nodecl, forwarddecl> = @record {}
global sfml.Http: type <cimport 'sfml.Http', nodecl, forwarddecl> = @record {}
global sfml.Packet: type <cimport 'sfml.Packet', nodecl, forwarddecl> = @record {}
global sfml.SocketSelector: type <cimport 'sfSocketSelector', nodecl, forwarddecl> = @record {}
global sfml.TcpListener: type <cimport 'sfTcpListener', nodecl, forwarddecl> = @record {}
global sfml.TcpSocket: type <cimport 'sfTcpSocket', nodecl, forwarddecl> = @record {}
global sfml.UdpSocket: type <cimport 'sfUdpSocket', nodecl, forwarddecl> = @record {}


-- Network: IpAddress
global sfml.IpAddress: type <cimport 'sfIpAddress', nodecl> = @record {
  address: [16]cchar
}

global sfml.IpAddress.None: sfml.IpAddress <cimport 'sfIpAddress_None', nodecl, const>
global sfml.IpAddress.Any: sfml.IpAddress <cimport 'sfIpAddress_Any', nodecl, const>
global sfml.IpAddress.LocalHost: sfml.IpAddress <cimport 'sfIpAddress_LocalHost', nodecl, const>
global sfml.IpAddress.Broadcast: sfml.IpAddress <cimport 'sfIpAddress_Broadcast', nodecl, const>

function sfml.IpAddress.fromString(address: cstring <const>): sfml.IpAddress <cimport 'sfIpAddress_fromString', nodecl> end
function sfml.IpAddress.fromBytes(byte0: sfUint8, byte1: sfUint8, byte2: sfUint8, byte3: sfUint8): sfml.IpAddress <cimport 'sfIpAddress_fromBytes', nodecl> end
function sfml.IpAddress.fromInteger(address: sfUint32): sfml.IpAddress <cimport 'sfIpAddress_fromInteger', nodecl> end
function sfml.IpAddress.toString(self: sfml.IpAddress, string: cstring): void <cimport 'sfIpAddress_toString', nodecl> end
function sfml.IpAddress.toInteger(self: sfml.IpAddress): sfUint32 <cimport 'sfIpAddress_toInteger', nodecl> end
function sfml.IpAddress.getLocalAddress(): sfml.IpAddress <cimport 'sfIpAddress_getLocalAddress', nodecl> end
function sfml.IpAddress.getPublicAddress(timeout: sfml.Time): sfml.IpAddress <cimport 'sfIpAddress_getPublicAddress', nodecl> end

-- Network: FTP
global sfml.FtpTransferMode: type <cimport 'sfFtpTransferMode', nodecl, using> = @enum(cint) {
  FtpBinary = 0,
  FtpAscii,
  FtpEbcdic
}

global sfml.FtpStatus: type <cimport 'sfFtpStatus', nodecl, using> = @enum(cint) {
  FtpRestartMarkerReply          = 110,
  FtpServiceReadySoon            = 120,
  FtpDataConnectionAlreadyOpened = 125,
  FtpOpeningDataConnection       = 150,  
  FtpOk                    = 200,
  FtpPointlessCommand      = 202,
  FtpSystemStatus          = 211,
  FtpDirectoryStatus       = 212,
  FtpFileStatus            = 213,
  FtpHelpMessage           = 214,
  FtpSystemType            = 215,
  FtpServiceReady          = 220,
  FtpClosingConnection     = 221,
  FtpDataConnectionOpened  = 225,
  FtpClosingDataConnection = 226,
  FtpEnteringPassiveMode   = 227,
  FtpLoggedIn              = 230,
  FtpFileActionOk          = 250,
  FtpDirectoryOk           = 257,
  FtpNeedPassword       = 331,
  FtpNeedAccountToLogIn = 332,
  FtpNeedInformation    = 350,

  FtpServiceUnavailable        = 421,
  FtpDataConnectionUnavailable = 425,
  FtpTransferAborted           = 426,
  FtpFileActionAborted         = 450,
  FtpLocalError                = 451,
  FtpInsufficientStorageSpace  = 452,
  FtpCommandUnknown          = 500,
  FtpParametersUnknown       = 501,
  FtpCommandNotImplemented   = 502,
  FtpBadCommandSequence      = 503,
  FtpParameterNotImplemented = 504,
  FtpNotLoggedIn             = 530,
  FtpNeedAccountToStore      = 532,
  FtpFileUnavailable         = 550,
  FtpPageTypeUnknown         = 551,
  FtpNotEnoughMemory         = 552,
  FtpFilenameNotAllowed      = 553,
  FtpInvalidResponse  = 1000,
  FtpConnectionFailed = 1001,
  FtpConnectionClosed = 1002,
  FtpInvalidFile      = 1003
}

function sfml.FtpListingResponse.destroy(self: *sfml.FtpListingResponse): void <cimport 'sfFtpListingResponse_destroy', nodecl> end
function sfml.FtpListingResponse.isOk(self: *sfml.FtpListingResponse <const>): sfBool <cimport 'sfFtpListingResponse_isOk', nodecl> end
function sfml.FtpListingResponse.getStatus(self: *sfml.FtpListingResponse <const>): sfml.FtpStatus <cimport 'sfFtpListingResponse_getStatus', nodecl> end
function sfml.FtpListingResponse.getMessage(self: *sfml.FtpListingResponse <const>): cstring <cimport 'sfFtpListingResponse_getMessage', nodecl> end
function sfml.FtpListingResponse.getCount(self: *sfml.FtpListingResponse <const>): csize <cimport 'sfFtpListingResponse_getCount', nodecl> end
function sfml.FtpListingResponse.getName(self: *sfml.FtpListingResponse <const>, index: csize): cstring <cimport 'sfFtpListingResponse_getName', nodecl> end

function sfml.FtpDirectoryResponse.destroy(self: *sfml.FtpListingResponse): void <cimport 'sfFtpDirectoryResponse_destroy', nodecl> end
function sfml.FtpDirectoryResponse.isOk(self: *sfml.FtpListingResponse <const>): sfBool <cimport 'sfFtpDirectoryResponse_isOk', nodecl> end
function sfml.FtpDirectoryResponse.getStatus(self: *sfml.FtpListingResponse <const>): sfml.FtpStatus <cimport 'sfFtpDirectoryResponse_getStatus', nodecl> end
function sfml.FtpDirectoryResponse.getMessage(self: *sfml.FtpListingResponse <const>): cstring <cimport 'sfFtpDirectoryResponse_getMessage', nodecl> end
function sfml.FtpDirectoryResponse.getDirectory(self: *sfml.FtpListingResponse <const>): cstring <cimport 'sfFtpDirectoryResponse_getDirectory', nodecl> end

function sfml.FtpResponse.destroy(self: *sfml.FtpResponse): void <cimport 'sfFtpResponse_destroy', nodecl> end
function sfml.FtpResponse.isOk(self: *sfml.FtpResponse <const>): sfBool <cimport 'sfFtpResponse_isOk', nodecl> end
function sfml.FtpResponse.getStatus(self: *sfml.FtpResponse <const>): sfml.FtpStatus <cimport 'sfFtpResponse_getStatus', nodecl> end
function sfml.FtpResponse.getMessage(self: *sfml.FtpResponse <const>): cstring <cimport 'sfFtpResponse_getMessage', nodecl> end

function sfml.Ftp.create(): *sfml.Ftp <cimport 'sfFtp_create', nodecl> end
function sfml.Ftp.destroy(self: *sfml.Ftp): void <cimport 'sfFtp_destroy', nodecl> end
function sfml.Ftp.connect(self: *sfml.Ftp, server: sfml.IpAddress, port: cushort, timeout: sfml.Time): *sfml.FtpResponse <cimport 'sfFtp_connect', nodecl> end
function sfml.Ftp.loginAnonymous(self: *sfml.Ftp): *sfml.FtpResponse <cimport 'sfFtp_loginAnonymous', nodecl> end
function sfml.Ftp.login(self: *sfml.Ftp, name: cstring <const>, password: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_login', nodecl> end
function sfml.Ftp.disconnect(self: *sfml.Ftp): *sfml.FtpResponse <cimport 'sfFtp_disconnect', nodecl> end
function sfml.Ftp.keepAlive(self: *sfml.Ftp): *sfml.FtpResponse <cimport 'sfFtp_keepAlive', nodecl> end
function sfml.Ftp.getWorkingDirectory(self: *sfml.Ftp): *sfml.FtpDirectoryResponse <cimport 'sfFtp_getWorkingDirectory', nodecl> end
function sfml.Ftp.getDirectoryListing(self: *sfml.Ftp, directory: cstring <const>): *sfml.FtpListingResponse <cimport 'sfFtp_getDirectoryListing', nodecl> end
function sfml.Ftp.changeDirectory(self: *sfml.Ftp, directory: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_changeDirectory', nodecl> end
function sfml.Ftp.parentDirectory(self: *sfml.Ftp): *sfml.FtpResponse <cimport 'sfFtp_parentDirectory', nodecl> end
function sfml.Ftp.createDirectory(self: *sfml.Ftp, name: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_createDirectory', nodecl> end
function sfml.Ftp.deleteDirectory(self: *sfml.Ftp, name: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_deleteDirectory', nodecl> end
function sfml.Ftp.renameFile(self: *sfml.Ftp, file: cstring <const>, newName: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_renameFile', nodecl> end
function sfml.Ftp.deleteFile(self: *sfml.Ftp, file: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_deleteFile', nodecl> end
function sfml.Ftp.download(self: *sfml.Ftp, remoteFile: cstring <const>, localPath: cstring <const>, mode: sfml.FtpTransferMode): *sfml.FtpResponse <cimport 'sfFtp_download', nodecl> end
function sfml.Ftp.upload(self: *sfml.Ftp, localFile: cstring <const>, remotePath: cstring <const>, mode: sfml.FtpTransferMode, append: sfBool): *sfml.FtpResponse <cimport 'sfFtp_upload', nodecl> end
function sfml.Ftp.sendCommand(self: *sfml.Ftp, command: cstring <const>, parameter: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_sendCommand', nodecl> end


-- Network: HTTP
global sfml.HttpMethod: type <cimport 'sfml.HttpMethod', nodecl, using> = @enum(cint) {
  HttpGet = 0,
  HttpPost,
  HttpHead,
  HttpPut,
  HttpDelete
}

global sfml.HttpStatus: type <cimport 'sfHttpStatus', nodecl, using> = @enum(cint) {
  HttpOk             = 200,
  HttpCreated        = 201,
  HttpAccepted       = 202,
  HttpNoContent      = 204,
  HttpResetContent   = 205,
  HttpPartialContent = 206,

  HttpMultipleChoices  = 300,
  HttpMovedPermanently = 301,
  HttpMovedTemporarily = 302,
  HttpNotModified      = 304,

  HttpBadRequest          = 400,
  HttpUnauthorized        = 401,
  HttpForbidden           = 403,
  HttpNotFound            = 404,
  HttpRangeNotSatisfiable = 407,

  HttpInternalServerError = 500,
  HttpNotImplemented      = 501,
  HttpBadGateway          = 502,
  HttpServiceNotAvailable = 503,
  HttpGatewayTimeout      = 504,
  HttpVersionNotSupported = 505,

  HttpInvalidResponse  = 1000,
  HttpConnectionFailed = 1001
}

function sfml.HttpRequest.create(): *sfml.HttpRequest <cimport 'sfHttpRequest_create', nodecl> end
function sfml.HttpRequest.destroy(self: *sfml.HttpRequest): void <cimport 'sfHttpRequest_destroy', nodecl> end
function sfml.HttpRequest.setField(self: *sfml.HttpRequest, field: cstring <const>, value: cstring <const>): void <cimport 'sfHttpRequest_setField', nodecl> end
function sfml.HttpRequest.setMethod(self: *sfml.HttpRequest, method: sfml.HttpMethod): void <cimport 'sfHttpRequest_setMethod', nodecl> end
function sfml.HttpRequest.setUri(self: *sfml.HttpRequest, uri: cstring <const>): void <cimport 'sfHttpRequest_setUri', nodecl> end
function sfml.HttpRequest.setHttpVersion(self: *sfml.HttpRequest, major: cuint, minor: cuint): void <cimport 'sfHttpRequest_setHttpVersion', nodecl> end
function sfml.HttpRequest.setBody(self: *sfml.HttpRequest, body: cstring <const>): void <cimport 'sfHttpRequest_setBody', nodecl> end

function sfml.HttpResponse.destroy(self: *sfml.HttpResponse): void <cimport 'sfHttpResponse_destroy', nodecl> end
function sfml.HttpResponse.getField(self: *sfml.HttpResponse <const>, field: cstring <const>): cstring <cimport 'sfHttpResponse_getField', nodecl> end
function sfml.HttpResponse.getStatus(self: *sfml.HttpResponse <const>): sfml.HttpStatus <cimport 'sfHttpResponse_getStatus', nodecl> end
function sfml.HttpResponse.getMajorVersion(self: *sfml.HttpResponse <const>): cuint <cimport 'sfHttpResponse_getMajorVersion', nodecl> end
function sfml.HttpResponse.getMinorVersion(self: *sfml.HttpResponse <const>): cuint <cimport 'sfHttpResponse_getMinorVersion', nodecl> end
function sfml.HttpResponse.getBody(self: *sfml.HttpResponse <const>): cstring <cimport 'sfHttpResponse_getBody', nodecl> end

function sfml.Http.create(): *sfml.Http <cimport 'sfHttp_create', nodecl> end
function sfml.Http.destroy(http: *sfml.Http): void <cimport 'sfHttp_destroy', nodecl> end
function sfml.Http.setHost(http: *sfml.Http, host: cstring <const>, port: cuint): void <cimport 'sfHttp_setHost', nodecl> end
function sfml.Http.sendRequest(http: *sfml.Http, request: *sfml.HttpRequest <const>, timeout: sfml.Time): *sfml.HttpResponse <cimport 'sfHttp_sendRequest', nodecl> end


 -- Network: Packet
function sfml.Packet.create(): *sfml.Packet <cimport 'sfPacket_create', nodecl> end
function sfml.Packet.copy(self: *sfml.Packet <const>): *sfml.Packet <cimport 'sfPacket_copy', nodecl> end
function sfml.Packet.destroy(self: *sfml.Packet): void <cimport 'sfPacket_destroy', nodecl> end
function sfml.Packet.append(self: *sfml.Packet, data: pointer, sizeInBytes: csize): void <cimport 'sfPacket_append', nodecl> end
function sfml.Packet.clear(self: *sfml.Packet): void <cimport 'sfPacket_clear', nodecl> end
function sfml.Packet.getData(self: *sfml.Packet <const>): pointer <cimport 'sfPacket_getData', nodecl> end
function sfml.Packet.getDataSize(self: *sfml.Packet <const>): csize <cimport 'sfPacket_getDataSize', nodecl> end
function sfml.Packet.endOfPacket(self: *sfml.Packet <const>): sfBool <cimport 'sfPacket_endOfPacket', nodecl> end
function sfml.Packet.canRead(self: *sfml.Packet <const>): sfBool <cimport 'sfPacket_canRead', nodecl> end

function sfml.Packet.readBool(self: *sfml.Packet): sfBool <cimport 'sfPacket_readBool', nodecl> end
function sfml.Packet.readInt8(self: *sfml.Packet): sfInt8 <cimport 'sfPacket_readInt8', nodecl> end
function sfml.Packet.readUint8(self: *sfml.Packet): sfUint8 <cimport 'sfPacket_readUint8', nodecl> end
function sfml.Packet.readInt16(self: *sfml.Packet): sfInt16 <cimport 'sfPacket_readInt16', nodecl> end
function sfml.Packet.readUint16(self: *sfml.Packet): sfUint16 <cimport 'sfPacket_readUint16', nodecl> end
function sfml.Packet.readInt32(self: *sfml.Packet): sfInt32 <cimport 'sfPacket_readInt32', nodecl> end
function sfml.Packet.readUint32(self: *sfml.Packet): sfUint32 <cimport 'sfPacket_readUint32', nodecl> end
function sfml.Packet.readFloat(self: *sfml.Packet): float32 <cimport 'sfPacket_readFloat', nodecl> end
function sfml.Packet.readDouble(self: *sfml.Packet): float64 <cimport 'sfPacket_readDouble', nodecl> end
function sfml.Packet.readString(self: *sfml.Packet, str: cstring): void <cimport 'sfPacket_readString', nodecl> end
function sfml.Packet.readWideString(self: *sfml.Packet, str: *[0]cint): void <cimport 'sfPacket_readWideString', nodecl> end

function sfml.Packet.writeBool(self: *sfml.Packet, data: sfBool): void <cimport 'sfPacket_writeBool', nodecl> end
function sfml.Packet.writeInt8(self: *sfml.Packet, data: sfInt8): void <cimport 'sfPacket_writeInt8', nodecl> end
function sfml.Packet.writeUint8(self: *sfml.Packet, data: sfUint8): void <cimport 'sfPacket_writeUint8', nodecl> end
function sfml.Packet.writeInt16(self: *sfml.Packet, data: sfInt16): void <cimport 'sfPacket_writeInt16', nodecl> end
function sfml.Packet.writeUint16(self: *sfml.Packet, data: sfUint16): void <cimport 'sfPacket_writeUint16', nodecl> end
function sfml.Packet.writeInt32(self: *sfml.Packet, data: sfInt32): void <cimport 'sfPacket_writeInt32', nodecl> end
function sfml.Packet.writeUint32(self: *sfml.Packet, data: sfUint32): void <cimport 'sfPacket_writeUint32', nodecl> end
function sfml.Packet.writeFloat(self: *sfml.Packet, data: float32): void <cimport 'sfPacket_writeFloat', nodecl> end
function sfml.Packet.writeDouble(self: *sfml.Packet, data: float64): void <cimport 'sfPacket_writeDouble', nodecl> end
function sfml.Packet.writeString(self: *sfml.Packet, data: cstring <const>): void <cimport 'sfPacket_writeString', nodecl> end
function sfml.Packet.writeWideString(self: *sfml.Packet, data: *[0]cint): void <cimport 'sfPacket_writeWideString', nodecl> end


-- Network: Selector
global sfml.SocketStatus: type <cimport 'sfSocketStatus', nodecl, using> = @enum(cint) {
  SocketDone = 0,
  SocketNotReady,
  SocketPartial,
  SocketDisconnected,
  SocketError
}

function sfml.SocketSelector.create(): *sfml.SocketSelector <cimport 'sfSocketSelector_create', nodecl> end
function sfml.SocketSelector.copy(self: *sfml.SocketSelector <const>): *sfml.SocketSelector <cimport 'sfSocketSelector_copy', nodecl> end
function sfml.SocketSelector.destroy(self: *sfml.SocketSelector): void <cimport 'sfSocketSelector_destroy', nodecl> end
function sfml.SocketSelector.addTcpListener(self: *sfml.SocketSelector, socket: *sfml.TcpListener): void <cimport 'sfSocketSelector_addTcpListener', nodecl> end
function sfml.SocketSelector.addTcpSocket(self: *sfml.SocketSelector, socket: *sfml.TcpSocket): void <cimport 'sfSocketSelector_addTcpSocket', nodecl> end
function sfml.SocketSelector.addUdpSocket(self: *sfml.SocketSelector, socket: *sfml.UdpSocket): void <cimport 'sfSocketSelector_addUdpSocket', nodecl> end
function sfml.SocketSelector.removeTcpListener(self: *sfml.SocketSelector, socket: *sfml.TcpListener): void <cimport 'sfSocketSelector_removeTcpListener', nodecl> end
function sfml.SocketSelector.removeTcpSocket(self: *sfml.SocketSelector, socket: *sfml.TcpSocket): void <cimport 'sfSocketSelector_removeTcpSocket', nodecl> end
function sfml.SocketSelector.removeUdpSocket(self: *sfml.SocketSelector, socket: *sfml.UdpSocket): void <cimport 'sfSocketSelector_removeUdpSocket', nodecl> end
function sfml.SocketSelector.clear(self: *sfml.SocketSelector): void <cimport 'sfSocketSelector_clear', nodecl> end
function sfml.SocketSelector.wait(self: *sfml.SocketSelector, timeout: sfml.Time): sfBool <cimport 'sfSocketSelector_wait', nodecl> end
function sfml.SocketSelector.isTcpListenerReady(self: *sfml.SocketSelector <const>, socket: *sfml.TcpListener): void <cimport 'sfSocketSelector_isTcpListenerReady', nodecl> end
function sfml.SocketSelector.isTcpSocketReady(self: *sfml.SocketSelector <const>, socket: *sfml.TcpSocket): void <cimport 'sfSocketSelector_isTcpSocketReady', nodecl> end
function sfml.SocketSelector.isUdpSocketReady(self: *sfml.SocketSelector <const>, socket: *sfml.UdpSocket): void <cimport 'sfSocketSelector_isUdpSocketReady', nodecl> end

function sfml.TcpListener.create(): *sfml.TcpListener <cimport 'sfTcpListener_create', nodecl> end
function sfml.TcpListener.destroy(self: *sfml.TcpListener): void <cimport 'sfTcpListener_destroy', nodecl> end
function sfml.TcpListener.setBlocking(self: *sfml.TcpListener, blocking: sfBool): void <cimport 'sfTcpListener_setBlocking', nodecl> end
function sfml.TcpListener.isBlocking(self: *sfml.TcpListener <const>): sfBool <cimport 'sfTcpListener_isBlocking', nodecl> end
function sfml.TcpListener.getLocalPort(self: *sfml.TcpListener <const>): cushort <cimport 'sfTcpListener_getLocalPort', nodecl> end
function sfml.TcpListener.listen(self: *sfml.TcpListener <const>, port: cushort, address: sfml.IpAddress): sfml.SocketStatus <cimport 'sfTcpListener_listen', nodecl> end
function sfml.TcpListener.accept(self: *sfml.TcpListener <const>, connected: *[0]*sfml.TcpSocket): sfml.SocketStatus <cimport 'sfTcpListener_accept', nodecl> end

function sfml.TcpSocket.create(): *sfml.TcpSocket <cimport 'sfTcpSocket_create', nodecl> end
function sfml.TcpSocket.destroy(self: *sfml.TcpSocket): void <cimport 'sfTcpSocket_destroy', nodecl> end
function sfml.TcpSocket.setBlocking(self: *sfml.TcpSocket, blocking: sfBool): void <cimport 'sfTcpSocket_setBlocking', nodecl> end
function sfml.TcpSocket.isBlocking(self: *sfml.TcpSocket <const>): sfBool <cimport 'sfTcpSocket_isBlocking', nodecl> end
function sfml.TcpSocket.getLocalPort(self: *sfml.TcpSocket <const>): cushort <cimport 'sfTcpSocket_getLocalPort', nodecl> end
function sfml.TcpSocket.getRemoteAddress(self: *sfml.TcpSocket <const>): sfml.IpAddress <cimport 'sfTcpSocket_getRemoteAddress', nodecl> end
function sfml.TcpSocket.getRemotePort(self: *sfml.TcpSocket <const>): cushort <cimport 'sfTcpSocket_getRemotePort', nodecl> end
function sfml.TcpSocket.connect(self: *sfml.TcpSocket, remoteAddress: sfml.IpAddress, remotePort: cushort, timeout: sfml.Time): sfml.SocketStatus <cimport 'sfTcpSocket_connect', nodecl> end
function sfml.TcpSocket.disconnect(self: *sfml.TcpSocket): void <cimport 'sfTcpSocket_disconnect', nodecl> end
function sfml.TcpSocket.send(self: *sfml.TcpSocket, data: pointer <const>, size: csize): sfml.SocketStatus <cimport 'sfTcpSocket_send', nodecl> end
function sfml.TcpSocket.sendPartial(self: *sfml.TcpSocket, data: pointer <const>, size: csize, received: *csize): sfml.SocketStatus <cimport 'sfTcpSocket_sendPartial', nodecl> end
function sfml.TcpSocket.receive(self: *sfml.TcpSocket, data: pointer <const>, size: csize, received: *csize): sfml.SocketStatus <cimport 'sfTcpSocket_receive', nodecl> end
function sfml.TcpSocket.sendPacket(self: *sfml.TcpSocket, packet: *sfml.Packet): sfml.SocketStatus <cimport 'sfTcpSocket_sendPacket', nodecl> end
function sfml.TcpSocket.receivePacket(self: *sfml.TcpSocket, packet: *sfml.Packet): sfml.SocketStatus <cimport 'sfTcpSocket_receivePacket', nodecl> end

function sfml.UdpSocket.create(): *sfml.UdpSocket <cimport 'sfUdpSocket_create', nodecl> end
function sfml.UdpSocket.destroy(self: *sfml.UdpSocket): void <cimport 'sfUdpSocket_destroy', nodecl> end
function sfml.UdpSocket.setBlocking(self: *sfml.UdpSocket, blocking: sfBool): void <cimport 'sfUdpSocket_setBlocking', nodecl> end
function sfml.UdpSocket.isBlocking(self: *sfml.UdpSocket <const>): sfBool <cimport 'sfUdpSocket_isBlocking', nodecl> end
function sfml.UdpSocket.getLocalPort(self: *sfml.UdpSocket <const>): cushort <cimport 'sfUdpSocket_getLocalPort', nodecl> end
function sfml.UdpSocket.bind(self: *sfml.UdpSocket <const>, port: cushort, address: sfml.IpAddress): sfml.SocketStatus <cimport 'sfUdpSocket_bind', nodecl> end
function sfml.UdpSocket.unbind(self: *sfml.UdpSocket): void <cimport 'sfUdpSocket_unbind', nodecl> end
function sfml.UdpSocket.send(self: *sfml.UdpSocket, data: pointer<const>, size: csize, remoteAddress: sfml.IpAddress, remotePort: cushort): sfml.SocketStatus <cimport 'sfUdpSocket_send', nodecl> end
function sfml.UdpSocket.receive(self: *sfml.UdpSocket, data: pointer, size: csize, received: *csize, remoteAddress: *sfml.IpAddress, remotePort: *cushort): sfml.SocketStatus <cimport 'sfUdpSocket_receive', nodecl> end
function sfml.UdpSocket.sendPacket(self: *sfml.UdpSocket, packet: *sfml.Packet, remoteAddress: sfml.IpAddress, remotePort: cushort): sfml.SocketStatus <cimport 'sfUdpSocket_sendPacket', nodecl> end
function sfml.UdpSocket.receivePacket(self: *sfml.UdpSocket, packet: *sfml.Packet, remoteAddress: *sfml.IpAddress, remotePort: *cushort): sfml.SocketStatus <cimport 'sfUdpSocket_receivePacket', nodecl> end
function sfml.UdpSocket.maxDatagramSize(): cuint <cimport 'sfUdpSocket_maxDatagramSize', nodecl> end

global sfml.Listener = @record{}
function sfml.Listener.setGlobalVolume(volume: float32): void <cimport 'sfListener_setGlobalVolume', nodecl> end
function sfml.Listener.getGlobalVolume(): float32 <cimport 'sfListener_getGlobalVolume', nodecl> end
function sfml.Listener.setPosition(position: sfml.Vector3f): void <cimport 'sfListener_setPosition', nodecl> end
function sfml.Listener.getPosition(): sfml.Vector3f <cimport 'sfListener_getPosition', nodecl> end
function sfml.Listener.setDirection(direction: sfml.Vector3f): void <cimport 'sfListener_setDirection', nodecl> end
function sfml.Listener.getDirection(): sfml.Vector3f <cimport 'sfListener_getDirection', nodecl> end
function sfml.Listener.setUpVector(upVector: sfml.Vector3f): void <cimport 'sfListener_setUpVector', nodecl> end
function sfml.Listener.getUpVector(): sfml.Vector3f <cimport 'sfListener_getUpVector', nodecl> end


-- Audio
global sfml.SoundStatus: type <cimport 'sfSoundStatus', nodecl, using> = @enum(cint) {
  Stopped = 0,
  Paused,
  Playing
}

global sfml.Music: type <cimport 'sfMusic', nodecl, forwarddecl> = @record {}
global sfml.Sound: type <cimport 'sfSound', nodecl, forwarddecl> = @record {}
global sfml.SoundBuffer: type <cimport 'sfSoundBuffer', nodecl, forwarddecl> = @record {}
global sfml.SoundBufferRecorder: type <cimport 'sfSoundBufferRecorder', nodecl, forwarddecl> = @record {}
global sfml.SoundRecorder: type <cimport 'sfSoundRecorder', nodecl, forwarddecl> = @record {}
global sfml.SoundStream: type <cimport 'sfSoundStream', nodecl, forwarddecl> = @record {}

global sfml.TimeSpan: type <cimport 'sfTimeSpan', nodecl> = @record {
  offset: sfml.Time,
  length: sfml.Time
}


-- Audio: Music
function sfml.Music.createFromFile(filename: cstring <const>): *sfml.Music <cimport 'sfMusic_createFromFile', nodecl> end
function sfml.Music.createFromMemory(data: pointer <const>, sizeInBytes: csize): *sfml.Music <cimport 'sfMusic_createFromMemory', nodecl> end
function sfml.Music.createFromStream(stream: *sfml.InputStream): *sfml.Music <cimport 'sfMusic_createFromStream', nodecl> end
function sfml.Music.destroy(self: *sfml.Music): void <cimport 'sfMusic_destroy', nodecl> end
function sfml.Music.setLoop(self: *sfml.Music, loop: sfBool): void <cimport 'sfMusic_setLoop', nodecl> end
function sfml.Music.getLoop(self: *sfml.Music <const>): sfBool <cimport 'sfMusic_getLoop', nodecl> end
function sfml.Music.getDuration(self: *sfml.Music <const>): sfml.Time <cimport 'sfMusic_getDuration', nodecl> end
function sfml.Music.getLoopPoints(self: *sfml.Music <const>): sfml.TimeSpan <cimport 'sfMusic_getLoopPoints', nodecl> end
function sfml.Music.setLoopPoints(self: *sfml.Music, timePoints: sfml.TimeSpan): void <cimport 'sfMusic_setLoopPoints', nodecl> end
function sfml.Music.play(self: *sfml.Music): void <cimport 'sfMusic_play', nodecl> end
function sfml.Music.pause(self: *sfml.Music): void <cimport 'sfMusic_pause', nodecl> end
function sfml.Music.stop(self: *sfml.Music): void <cimport 'sfMusic_stop', nodecl> end
function sfml.Music.getChannelCount(self: *sfml.Music <const>): cuint <cimport 'sfMusic_getChannelCount', nodecl> end
function sfml.Music.getSampleRate(self: *sfml.Music <const>): cuint <cimport 'sfMusic_getSampleRate', nodecl> end
function sfml.Music.getStatus(self: *sfml.Music <const>): sfml.SoundStatus <cimport 'sfMusic_getStatus', nodecl> end
function sfml.Music.getPlayingOffset(self: *sfml.Music <const>): sfml.Time <cimport 'sfMusic_getPlayingOffset', nodecl> end
function sfml.Music.setPitch(self: *sfml.Music, pitch: float32): void <cimport 'sfMusic_setPitch', nodecl> end
function sfml.Music.setVolume(self: *sfml.Music, volume: float32): void <cimport 'sfMusic_setVolume', nodecl> end
function sfml.Music.setPosition(self: *sfml.Music, position: sfml.Vector3f): void <cimport 'sfMusic_setPosition', nodecl> end
function sfml.Music.setRelativeToListener(music: *sfml.Music, relative: sfBool): void <cimport 'sfMusic_setRelativeToListener', nodecl> end
function sfml.Music.setMinDistance(self: *sfml.Music, distance: float32): void <cimport 'sfMusic_setMinDistance', nodecl> end
function sfml.Music.setAttenuation(self: *sfml.Music, attenuation: float32): void <cimport 'sfMusic_setAttenuation', nodecl> end
function sfml.Music.setPlayingOffset(self: *sfml.Music, timeOffset: sfml.Time): void <cimport 'sfMusic_setPlayingOffset', nodecl> end
function sfml.Music.getPitch(self: *sfml.Music <const>): float32 <cimport 'sfMusic_getPitch', nodecl> end
function sfml.Music.getVolume(self: *sfml.Music <const>): float32 <cimport 'sfMusic_getVolume', nodecl> end
function sfml.Music.getPosition(self: *sfml.Music <const>): sfml.Vector3f <cimport 'sfMusic_getPosition', nodecl> end
function sfml.Music.isRelativeToListener(self: *sfml.Music <const>): sfBool <cimport 'sfMusic_isRelativeToListener', nodecl> end
function sfml.Music.getMinDistance(self: *sfml.Music <const>): float32 <cimport 'sfMusic_getMinDistance', nodecl> end
function sfml.Music.getAttenuation(self: *sfml.Music <const>): float32 <cimport 'sfMusic_getAttenuation', nodecl> end


-- Audio: Sound
function sfml.Sound.create(): *sfml.Sound <cimport 'sfSound_create', nodecl> end
function sfml.Sound.copy(self: *sfml.Sound <const>): *sfml.Sound <cimport 'sfSound_copy', nodecl> end
function sfml.Sound.destroy(self: *sfml.Sound): void <cimport 'sfSound_destroy', nodecl> end
function sfml.Sound.play(self: *sfml.Sound): void <cimport 'sfSound_play', nodecl> end
function sfml.Sound.pause(self: *sfml.Sound): void <cimport 'sfSound_pause', nodecl> end
function sfml.Sound.stop(self: *sfml.Sound): void <cimport 'sfSound_stop', nodecl> end
function sfml.Sound.setBuffer(self: *sfml.Sound, buffer: *sfml.SoundBuffer <const>): void <cimport 'sfSound_setBuffer', nodecl> end
function sfml.Sound.getBuffer(self: *sfml.Sound <const>): *sfml.SoundBuffer <cimport 'sfSound_getBuffer', nodecl> end
function sfml.Sound.setLoop(self: *sfml.Sound, loop: sfBool): void <cimport 'sfSound_setLoop', nodecl> end
function sfml.Sound.getLoop(self: *sfml.Sound <const>): sfBool <cimport 'sfSound_getLoop', nodecl> end
function sfml.Sound.getStatus(self: *sfml.Sound <const>): sfml.SoundStatus <cimport 'sfSound_getStatus', nodecl> end
function sfml.Sound.setPitch(self: *sfml.Sound, pitch: float32): void <cimport 'sfSound_setPitch', nodecl> end
function sfml.Sound.setVolume(self: *sfml.Sound, volume: float32): void <cimport 'sfSound_setVolume', nodecl> end
function sfml.Sound.setPosition(self: *sfml.Sound, position: sfml.Vector3f): void <cimport 'sfSound_setPosition', nodecl> end
function sfml.Sound.setRelativeToListener(self: *sfml.Sound, relative: sfBool): void <cimport 'sfSound_setRelativeToListener', nodecl> end
function sfml.Sound.setMinDistance(self: *sfml.Sound, distance: float32): void <cimport 'sfSound_setMinDistance', nodecl> end
function sfml.Sound.setAttenuation(self: *sfml.Sound, attenuation: float32): void <cimport 'sfSound_setAttenuation', nodecl> end
function sfml.Sound.setPlayingOffset(self: *sfml.Sound, timeOffset: sfml.Time): void <cimport 'sfSound_setPlayingOffset', nodecl> end
function sfml.Sound.getPitch(self: *sfml.Sound <const>): float32 <cimport 'sfSound_getPitch', nodecl> end
function sfml.Sound.getVolume(self: *sfml.Sound <const>): float32 <cimport 'sfSound_getVolume', nodecl> end
function sfml.Sound.getPosition(self: *sfml.Sound <const>): sfml.Vector3f <cimport 'sfSound_getPosition', nodecl> end
function sfml.Sound.isRelativeToListener(self: *sfml.Sound <const>): sfBool <cimport 'sfSound_isRelativeToListener', nodecl> end
function sfml.Sound.getMinDistance(self: *sfml.Sound <const>): float32 <cimport 'sfSound_getMinDistance', nodecl> end
function sfml.Sound.getAttenuation(self: *sfml.Sound <const>): float32 <cimport 'sfSound_getAttenuation', nodecl> end
function sfml.Sound.getPlayingOffset(self: *sfml.Sound <const>): sfml.Time <cimport 'sfSound_getPlayingOffset', nodecl> end


-- Audio: Sound Buffer
function sfml.SoundBuffer.createFromFile(filename: cstring <const>): *sfml.SoundBuffer <cimport 'sfSoundBuffer_createFromFile', nodecl> end
function sfml.SoundBuffer.createFromMemory(data: pointer <const>, sizeInBytes: csize): *sfml.SoundBuffer <cimport 'sfSoundBuffer_createFromMemory', nodecl> end
function sfml.SoundBuffer.createFromStream(stream: *sfml.InputStream): *sfml.SoundBuffer <cimport 'sfSoundBuffer_createFromStream', nodecl> end
function sfml.SoundBuffer.createFromSamples(samples: *[0]sfInt16, sampleCount: sfUint64, channelCount: cuint, sampleRate: cuint): *sfml.SoundBuffer <cimport 'sfSoundBuffer_createFromSamples', nodecl> end
function sfml.SoundBuffer.copy(self: *sfml.SoundBuffer <const>): *sfml.SoundBuffer <cimport 'sfSoundBuffer_copy', nodecl> end
function sfml.SoundBuffer.destroy(self: *sfml.SoundBuffer): void <cimport 'sfSoundBuffer_destroy', nodecl> end
function sfml.SoundBuffer.saveToFile(self: *sfml.SoundBuffer <const>, filename: cstring <const>): sfBool <cimport 'sfSoundBuffer_saveToFile', nodecl> end
function sfml.SoundBuffer.getSamples(self: *sfml.SoundBuffer <const>): *[0]sfInt16 <cimport 'sfSoundBuffer_getSamples', nodecl> end
function sfml.SoundBuffer.getSampleCount(self: *sfml.SoundBuffer <const>): sfUint64 <cimport 'sfSoundBuffer_getSampleCount', nodecl> end
function sfml.SoundBuffer.getSampleRate(self: *sfml.SoundBuffer <const>): cuint <cimport 'sfSoundBuffer_getSampleRate', nodecl> end
function sfml.SoundBuffer.getChannelCount(self: *sfml.SoundBuffer <const>): cuint <cimport 'sfSoundBuffer_getChannelCount', nodecl> end
function sfml.SoundBuffer.getDuration(self: *sfml.SoundBuffer <const>): sfml.Time <cimport 'sfSoundBuffer_getDuration', nodecl> end


-- Audio: Sound Buffer Recorder
function sfml.SoundBufferRecorder.create(): *sfml.SoundBufferRecorder <cimport 'sfSoundBufferRecorder_create', nodecl> end
function sfml.SoundBufferRecorder.destroy(self: *sfml.SoundBufferRecorder): void <cimport 'sfSoundBufferRecorder_destroy', nodecl> end
function sfml.SoundBufferRecorder.start(self: *sfml.SoundBufferRecorder, sampleRate: cuint): sfBool <cimport 'sfSoundBufferRecorder_start', nodecl> end
function sfml.SoundBufferRecorder.stop(self: *sfml.SoundBufferRecorder): void <cimport 'sfSoundBufferRecorder_stop', nodecl> end
function sfml.SoundBufferRecorder.getSampleRate(self: *sfml.SoundBufferRecorder <const>): cuint <cimport 'sfSoundBufferRecorder_getSampleRate', nodecl> end
function sfml.SoundBufferRecorder.getBuffer(self: *sfml.SoundBufferRecorder <const>): *sfml.SoundBuffer <cimport 'sfSoundBufferRecorder_getBuffer', nodecl> end
function sfml.SoundBufferRecorder.setDevice(self: *sfml.SoundBufferRecorder <const>, name: cstring <const>): sfBool <cimport 'sfSoundBufferRecorder_setDevice', nodecl> end
function sfml.SoundBufferRecorder.getDevice(self: *sfml.SoundBufferRecorder): cstring <cimport 'sfSoundBufferRecorder_getDevice', nodecl> end


global sfml.SoundRecorderStartCallback: type <cimport 'sfSoundRecorderStartCallback', nodecl> = @function(pointer): sfBool
global sfml.SoundRecorderProcessCallback: type <cimport 'sfSoundRecorderProcessCallback', nodecl> = @function(*[0]sfInt16, csize, pointer): sfBool
global sfml.SoundRecorderStopCallback: type <cimport 'sfSoundRecorderStopCallback', nodecl> = @function(pointer): void


-- Audio: Sound Recorder
function sfml.SoundRecorder.create(onStart: sfml.SoundRecorderStartCallback, onProcess: sfml.SoundRecorderProcessCallback, onStop: sfml.SoundRecorderStopCallback, userData: pointer): *sfml.SoundRecorder <cimport 'sfSoundRecorder_create', nodecl> end
function sfml.SoundRecorder.destroy(self: *sfml.SoundRecorder): void <cimport 'sfSoundRecorder_destroy', nodecl> end
function sfml.SoundRecorder.start(self: *sfml.SoundRecorder, sampleRate: cuint): sfBool <cimport 'sfSoundRecorder_start', nodecl> end
function sfml.SoundRecorder.stop(self: *sfml.SoundRecorder): void <cimport 'sfSoundRecorder_stop', nodecl> end
function sfml.SoundRecorder.getSampleRate(self: *sfml.SoundRecorder <const>): cuint <cimport 'sfSoundRecorder_getSampleRate', nodecl> end
function sfml.SoundRecorder.isAvailable(): sfBool <cimport 'sfSoundRecorder_isAvailable', nodecl> end
function sfml.SoundRecorder.setProcessingInterval(self: *sfml.SoundRecorder, interval: sfml.Time): void <cimport 'sfSoundRecorder_setProcessingInterval', nodecl> end
function sfml.SoundRecorder.getAvailableDevices(count: csize): *[0]cstring <cimport 'sfSoundRecorder_getAvailableDevices', nodecl> end
function sfml.SoundRecorder.getDefaultDevice(): cstring <cimport 'sfSoundRecorder_getDefaultDevice', nodecl> end
function sfml.SoundRecorder.setDevice(self: *sfml.SoundRecorder, name: cstring <const>): sfBool <cimport 'sfSoundRecorder_setDevice', nodecl> end
function sfml.SoundRecorder.getDevice(self: *sfml.SoundRecorder): cstring <cimport 'sfSoundRecorder_getDevice', nodecl> end
function sfml.SoundRecorder.setChannelCount(self: *sfml.SoundRecorder, channelCount: cuint): void <cimport 'sfSoundRecorder_setChannelCount', nodecl> end
function sfml.SoundRecorder.getChannelCount(self: *sfml.SoundRecorder <const>): cuint <cimport 'sfSoundRecorder_getChannelCount', nodecl> end


-- Audio: SoundStream
global sfml.SoundStreamChunk: type <cimport 'sfSoundStreamChunk', nodecl> = @record {
  samples: *[0]sfInt16,
  sampleCount: cuint
}

global sfml.SoundStreamGetDataCallback: type <cimport 'sfSoundStreamGetDataCallback', nodecl> = @function(*sfml.SoundStreamChunk, pointer): sfBool
global sfml.SoundStreamSeekCallback: type <cimport 'sfSoundStreamSeekCallback', nodecl> = @function(sfml.Time, pointer): void

function sfml.SoundStream.create(onGetData: sfml.SoundStreamGetDataCallback, onSeek: sfml.SoundStreamSeekCallback, channelCount: cuint, sampleRate: cuint, userData: pointer): *sfml.SoundStream <cimport 'sfSoundStream_create', nodecl> end
function sfml.SoundStream.destroy(self: *sfml.SoundStream): void <cimport 'sfSoundStream_destroy', nodecl> end
function sfml.SoundStream.play(self: *sfml.SoundStream): void <cimport 'sfSoundStream_play', nodecl> end
function sfml.SoundStream.pause(self: *sfml.SoundStream): void <cimport 'sfSoundStream_pause', nodecl> end
function sfml.SoundStream.stop(self: *sfml.SoundStream): void <cimport 'sfSoundStream_stop', nodecl> end
function sfml.SoundStream.getStatus(self: *sfml.SoundStream <const>): sfml.SoundStatus <cimport 'sfSoundStream_getStatus', nodecl> end
function sfml.SoundStream.getChannelCount(self: *sfml.SoundStream <const>): cuint <cimport 'sfSoundStream_getChannelCount', nodecl> end
function sfml.SoundStream.setPitch(self: *sfml.SoundStream, pitch: float32): void <cimport 'sfSoundStream_setPitch', nodecl> end
function sfml.SoundStream.setVolume(self: *sfml.SoundStream, volume: float32): void <cimport 'sfSoundStream_setVolume', nodecl> end
function sfml.SoundStream.setPosition(self: *sfml.SoundStream, position: sfml.Vector3f): void <cimport 'sfSoundStream_setPosition', nodecl> end
function sfml.SoundStream.setRelativeToListener(self: *sfml.SoundStream, relative: sfBool): void <cimport 'sfSoundStream_setRelativeToListener', nodecl> end
function sfml.SoundStream.setMinDistance(self: *sfml.SoundStream, distance: float32): void <cimport 'sfSoundStream_setMinDistance', nodecl> end
function sfml.SoundStream.setAttenuation(self: *sfml.SoundStream, attenuation: float32): void <cimport 'sfSoundStream_setAttenuation', nodecl> end
function sfml.SoundStream.setPlayingOffset(self: *sfml.SoundStream, timeOffset: sfml.Time): void <cimport 'sfSoundStream_setPlayingOffset', nodecl> end
function sfml.SoundStream.setLoop(self: *sfml.SoundStream, loop: sfBool): void <cimport 'sfSoundStream_setLoop', nodecl> end
function sfml.SoundStream.getPitch(self: *sfml.SoundStream <const>): float32 <cimport 'sfSoundStream_getPitch', nodecl> end
function sfml.SoundStream.getVolume(self: *sfml.SoundStream <const>): float32 <cimport 'sfSoundStream_getVolume', nodecl> end
function sfml.SoundStream.getPosition(self: *sfml.SoundStream <const>): sfml.Vector3f <cimport 'sfSoundStream_getPosition', nodecl> end
function sfml.SoundStream.isRelativeToListener(self: *sfml.SoundStream <const>): sfBool <cimport 'sfSoundStream_isRelativeToListener', nodecl> end
function sfml.SoundStream.getMinDistance(self: *sfml.SoundStream <const>): float32 <cimport 'sfSoundStream_getMinDistance', nodecl> end
function sfml.SoundStream.getAttenuation(self: *sfml.SoundStream <const>): float32 <cimport 'sfSoundStream_getAttenuation', nodecl> end
function sfml.SoundStream.getLoop(self: *sfml.SoundStream <const>): sfBool <cimport 'sfSoundStream_getLoop', nodecl> end
function sfml.SoundStream.getPlayingOffset(self: *sfml.SoundStream <const>): sfml.Time <cimport 'sfSoundStream_getPlayingOffset', nodecl> end