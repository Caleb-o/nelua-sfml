global sfml = @record{}

##[[
  cinclude "SFML/Config.h"
  cinclude "SFML/GPUPreference.h"
  cinclude "SFML/System.h"
  cinclude "SFML/Audio.h"
  cinclude "SFML/Network.h"
  cinclude "SFML/Window.h"
  cinclude "SFML/Graphics.h"
  
  linklib "csfml-audio"
  linklib "csfml-graphics"
  linklib "csfml-network"
  linklib "csfml-system"
  linklib "csfml-window"
]]

-- Global Information
global sfml.VERSION_MAJOR: cint <cimport 'CSFML_VERSION_MAJOR', nodecl, const>
global sfml.VERSION_MINOR: cint <cimport 'CSFML_VERSION_MINOR', nodecl, const>
global sfml.VERSION_PATCH: cint <cimport 'CSFML_VERSION_PATCH', nodecl, const>
global sfml.SYSTEM_WINDOWS: cint <cimport 'CSFML_SYSTEM_WINDOWS', nodecl, const>
global sfml.SYSTEM_LINUX: cint <cimport 'CSFML_SYSTEM_LINUX', nodecl, const>
global sfml.SYSTEM_MACOS: cint <cimport 'CSFML_SYSTEM_MACOS', nodecl, const>
global sfml.SYSTEM_FREEBSD: cint <cimport 'CSFML_SYSTEM_FREEBSD', nodecl, const>


-- Types
global sfml.Bool: type <cimport 'sfBool', nodecl> = @boolean
global sfml.False: boolean <cimport 'sfFalse', nodecl, const>
global sfml.True: boolean <cimport 'sfTrue', nodecl, const>

global sfml.Int8: type <cimport 'sfInt8', nodecl> = @int8
global sfml.Uint8: type <cimport 'sfUint8', nodecl> = @byte
global sfml.Int16: type <cimport 'sfInt16', nodecl> = @int16
global sfml.Uint16: type <cimport 'sfUint16', nodecl> = @uint16
global sfml.Int32: type <cimport 'sfInt32', nodecl> = @int32
global sfml.Uint32: type <cimport 'sfUint32', nodecl> = @uint32
global sfml.Int64: type <cimport 'sfInt64', nodecl> = @int64
global sfml.Uint64: type <cimport 'sfUint64', nodecl> = @uint64


-- Time
global sfml.Time: type <cimport 'sfTime', nodecl> = @record {
  microseconds: sfml.Int64
}

global sfml.Time.zero: sfml.Time <cimport 'sfTime_Zero', nodecl, const>

function sfml.Time.as_seconds(self: sfml.Time): float32 <cimport 'sfTime_asSeconds', nodecl> end
function sfml.Time.as_milliseconds(self: sfml.Time): sfml.Int32 <cimport 'sfTime_asMilliseconds', nodecl> end
function sfml.Time.as_microseconds(self: sfml.Time): sfml.Int64 <cimport 'sfTime_asMicroseconds', nodecl> end

function sfml.Time.seconds(amount: float32): sfml.Time <cimport 'sfSeconds', nodecl> end
function sfml.Time.milliseconds(amount: sfml.Int32): sfml.Time <cimport 'sfMilliseconds', nodecl> end
function sfml.Time.microseconds(amount: sfml.Int64): sfml.Time <cimport 'sfMicroseconds', nodecl> end


-- Clock
global sfml.Clock: type <cimport 'sfClock', nodecl, forwarddecl> = @record {}

function sfml.Clock.create(): *sfml.Clock <cimport 'sfClock_create', nodecl> end
function sfml.Clock.copy(self: *sfml.Clock <const>): *sfml.Clock <cimport 'sfClock_copy', nodecl> end
function sfml.Clock.destroy(self: *sfml.Clock): void <cimport 'sfClock_destroy', nodecl> end
function sfml.Clock.get_elapsed_time(self: *sfml.Clock <const>): sfml.Time <cimport 'sfClock_getElapsedTime', nodecl> end
function sfml.Clock.restart(self: *sfml.Clock): sfml.Time <cimport 'sfClock_restart', nodecl> end


-- InputStream
global sfml.InputStreamReadFunc: type <cimport 'sfInputStreamReadFunc', nodecl> = @function(pointer, sfml.Int64, pointer): sfml.Int64
global sfml.InputStreamSeekFunc: type <cimport 'sfInputStreamSeekFunc', nodecl> = @function(sfml.Int64, pointer): sfml.Int64
global sfml.InputStreamTellFunc: type <cimport 'sfInputStreamTellFunc', nodecl> = @function(pointer): sfml.Int64
global sfml.InputStreamGetSizeFunc: type <cimport 'sfInputStreamGetSizeFunc', nodecl> = @function(pointer): sfml.Int64

global sfml.InputStream: type <cimport 'sfInputStream', nodecl> = @record {
  read: sfml.InputStreamReadFunc,
  seek: sfml.InputStreamSeekFunc,
  tell: sfml.InputStreamTellFunc,
  getSize: sfml.InputStreamGetSizeFunc,
  userData: pointer
}

-- Mutex
global sfml.Mutex: type <cimport 'sfMutex', nodecl, forwarddecl> = @record {}

function sfml.Mutex.create(): *sfml.Mutex <cimport 'sfMutex_create', nodecl> end
function sfml.Mutex.destroy(self: *sfml.Mutex): void <cimport 'sfMutex_destroy', nodecl> end
function sfml.Mutex.lock(self: *sfml.Mutex): void <cimport 'sfMutex_lock', nodecl> end
function sfml.Mutex.unlock(self: *sfml.Mutex): void <cimport 'sfMutex_unlock', nodecl> end

function sfml.Time.sleep(duration: sfml.Time): void <cimport 'sfSleep', nodecl> end

-- Thread
global sfml.Thread: type <cimport 'sfThread', nodecl, forwarddecl> = @record {}

function sfml.Thread.create(f: function(pointer): void, userdata: pointer): *sfml.Thread <cimport 'sfThread_create', nodecl> end
function sfml.Thread.destroy(self: *sfml.Thread): void <cimport 'sfThread_destroy', nodecl> end
function sfml.Thread.launch(self: *sfml.Thread): void <cimport 'sfThread_launch', nodecl> end
function sfml.Thread.wait(self: *sfml.Thread): void <cimport 'sfThread_wait', nodecl> end
function sfml.Thread.terminate(self: *sfml.Thread): void <cimport 'sfThread_terminate', nodecl> end


-- Vector
global sfml.Vector2i: type <cimport 'sfVector2i', nodecl> = @record {
  x: cint,
  y: cint
}

global sfml.Vector2u: type <cimport 'sfVector2u', nodecl> = @record {
  x: cuint,
  y: cuint
}

global sfml.Vector2f: type <cimport 'sfVector2f', nodecl> = @record {
  x: float32,
  y: float32
}

global sfml.Vector3f: type <cimport 'sfVector3f', nodecl> = @record {
  x: float32,
  y: float32,
  z: float32
}


-- Network
global sfml.FtpDirectoryResponse: type <cimport 'sfFtpDirectoryResponse', nodecl, forwarddecl> = @record {}
global sfml.FtpListingResponse: type <cimport 'sfFtpListingResponse', nodecl, forwarddecl> = @record {}
global sfml.FtpResponse: type <cimport 'sfFtpResponse', nodecl, forwarddecl> = @record {}
global sfml.Ftp: type <cimport 'sfFtp', nodecl, forwarddecl> = @record {}
global sfml.HttpRequest: type <cimport 'sfml.HttpRequest', nodecl, forwarddecl> = @record {}
global sfml.HttpResponse: type <cimport 'sfml.HttpResponse', nodecl, forwarddecl> = @record {}
global sfml.Http: type <cimport 'sfml.Http', nodecl, forwarddecl> = @record {}
global sfml.Packet: type <cimport 'sfml.Packet', nodecl, forwarddecl> = @record {}
global sfml.SocketSelector: type <cimport 'sfSocketSelector', nodecl, forwarddecl> = @record {}
global sfml.TcpListener: type <cimport 'sfTcpListener', nodecl, forwarddecl> = @record {}
global sfml.TcpSocket: type <cimport 'sfTcpSocket', nodecl, forwarddecl> = @record {}
global sfml.UdpSocket: type <cimport 'sfUdpSocket', nodecl, forwarddecl> = @record {}


-- Network: IpAddress
global sfml.IpAddress: type <cimport 'sfIpAddress', nodecl> = @record {
  address: [16]byte
}

global sfml.IpAddress.None: sfml.IpAddress <cimport 'sfIpAddress_None', nodecl, const>
global sfml.IpAddress.Any: sfml.IpAddress <cimport 'sfIpAddress_Any', nodecl, const>
global sfml.IpAddress.LocalHost: sfml.IpAddress <cimport 'sfIpAddress_LocalHost', nodecl, const>
global sfml.IpAddress.Broadcast: sfml.IpAddress <cimport 'sfIpAddress_Broadcast', nodecl, const>

function sfml.IpAddress.from_string(address: cstring <const>): sfml.IpAddress <cimport 'sfIpAddress_fromString', nodecl> end
function sfml.IpAddress.from_bytes(byte0: sfml.Uint8, byte1: sfml.Uint8, byte2: sfml.Uint8, byte3: sfml.Uint8): sfml.IpAddress <cimport 'sfIpAddress_fromBytes', nodecl> end
function sfml.IpAddress.from_integer(address: sfml.Uint32): sfml.IpAddress <cimport 'sfIpAddress_fromInteger', nodecl> end
function sfml.IpAddress.to_string(self: sfml.IpAddress, string: cstring): void <cimport 'sfIpAddress_toString', nodecl> end
function sfml.IpAddress.to_integer(self: sfml.IpAddress): sfml.Uint32 <cimport 'sfIpAddress_toInteger', nodecl> end
function sfml.IpAddress.get_local_address(): sfml.IpAddress <cimport 'sfIpAddress_getLocalAddress', nodecl> end
function sfml.IpAddress.get_public_address(timeout: sfml.Time): sfml.IpAddress <cimport 'sfIpAddress_getPublicAddress', nodecl> end

-- Network: FTP
global sfml.FtpTransferMode: type <cimport 'sfFtpTransferMode', nodecl, using> = @enum(cint) {
  Binary = 0,
  Ascii,
  Ebcdic
}

global sfml.FtpStatus: type <cimport 'sfFtpStatus', nodecl, using> = @enum(cint) {
  RestartMarkerReply          = 110,
  ServiceReadySoon            = 120,
  DataConnectionAlreadyOpened = 125,
  OpeningDataConnection       = 150,  
  Ok                    = 200,
  PointlessCommand      = 202,
  SystemStatus          = 211,
  DirectoryStatus       = 212,
  FileStatus            = 213,
  HelpMessage           = 214,
  SystemType            = 215,
  ServiceReady          = 220,
  ClosingConnection     = 221,
  DataConnectionOpened  = 225,
  ClosingDataConnection = 226,
  EnteringPassiveMode   = 227,
  LoggedIn              = 230,
  FileActionOk          = 250,
  DirectoryOk           = 257,
  NeedPassword       = 331,
  NeedAccountToLogIn = 332,
  NeedInformation    = 350,

  ServiceUnavailable        = 421,
  DataConnectionUnavailable = 425,
  TransferAborted           = 426,
  FileActionAborted         = 450,
  LocalError                = 451,
  InsufficientStorageSpace  = 452,
  CommandUnknown          = 500,
  ParametersUnknown       = 501,
  CommandNotImplemented   = 502,
  BadCommandSequence      = 503,
  ParameterNotImplemented = 504,
  NotLoggedIn             = 530,
  NeedAccountToStore      = 532,
  FileUnavailable         = 550,
  PageTypeUnknown         = 551,
  NotEnoughMemory         = 552,
  FilenameNotAllowed      = 553,
  InvalidResponse  = 1000,
  ConnectionFailed = 1001,
  ConnectionClosed = 1002,
  InvalidFile      = 1003
}

function sfml.FtpListingResponse.destroy(self: *sfml.FtpListingResponse): void <cimport 'sfFtpListingResponse_destroy', nodecl> end
function sfml.FtpListingResponse.is_ok(self: *sfml.FtpListingResponse <const>): sfml.Bool <cimport 'sfFtpListingResponse_isOk', nodecl> end
function sfml.FtpListingResponse.get_status(self: *sfml.FtpListingResponse <const>): sfml.FtpStatus <cimport 'sfFtpListingResponse_getStatus', nodecl> end
function sfml.FtpListingResponse.get_message(self: *sfml.FtpListingResponse <const>): cstring <cimport 'sfFtpListingResponse_getMessage', nodecl> end
function sfml.FtpListingResponse.get_count(self: *sfml.FtpListingResponse <const>): csize <cimport 'sfFtpListingResponse_getCount', nodecl> end
function sfml.FtpListingResponse.get_name(self: *sfml.FtpListingResponse <const>, index: csize): cstring <cimport 'sfFtpListingResponse_getName', nodecl> end

function sfml.FtpDirectoryResponse.destroy(self: *sfml.FtpListingResponse): void <cimport 'sfFtpDirectoryResponse_destroy', nodecl> end
function sfml.FtpDirectoryResponse.is_ok(self: *sfml.FtpListingResponse <const>): sfml.Bool <cimport 'sfFtpDirectoryResponse_isOk', nodecl> end
function sfml.FtpDirectoryResponse.get_status(self: *sfml.FtpListingResponse <const>): sfml.FtpStatus <cimport 'sfFtpDirectoryResponse_getStatus', nodecl> end
function sfml.FtpDirectoryResponse.get_message(self: *sfml.FtpListingResponse <const>): cstring <cimport 'sfFtpDirectoryResponse_getMessage', nodecl> end
function sfml.FtpDirectoryResponse.get_directory(self: *sfml.FtpListingResponse <const>): cstring <cimport 'sfFtpDirectoryResponse_getDirectory', nodecl> end

function sfml.FtpResponse.destroy(self: *sfml.FtpResponse): void <cimport 'sfFtpResponse_destroy', nodecl> end
function sfml.FtpResponse.is_ok(self: *sfml.FtpResponse <const>): sfml.Bool <cimport 'sfFtpResponse_isOk', nodecl> end
function sfml.FtpResponse.get_status(self: *sfml.FtpResponse <const>): sfml.FtpStatus <cimport 'sfFtpResponse_getStatus', nodecl> end
function sfml.FtpResponse.get_message(self: *sfml.FtpResponse <const>): cstring <cimport 'sfFtpResponse_getMessage', nodecl> end

function sfml.Ftp.create(): *sfml.Ftp <cimport 'sfFtp_create', nodecl> end
function sfml.Ftp.destroy(self: *sfml.Ftp): void <cimport 'sfFtp_destroy', nodecl> end
function sfml.Ftp.connect(self: *sfml.Ftp, server: sfml.IpAddress, port: cushort, timeout: sfml.Time): *sfml.FtpResponse <cimport 'sfFtp_connect', nodecl> end
function sfml.Ftp.login_anonymous(self: *sfml.Ftp): *sfml.FtpResponse <cimport 'sfFtp_loginAnonymous', nodecl> end
function sfml.Ftp.login(self: *sfml.Ftp, name: cstring <const>, password: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_login', nodecl> end
function sfml.Ftp.disconnect(self: *sfml.Ftp): *sfml.FtpResponse <cimport 'sfFtp_disconnect', nodecl> end
function sfml.Ftp.keep_alive(self: *sfml.Ftp): *sfml.FtpResponse <cimport 'sfFtp_keepAlive', nodecl> end
function sfml.Ftp.get_working_directory(self: *sfml.Ftp): *sfml.FtpDirectoryResponse <cimport 'sfFtp_getWorkingDirectory', nodecl> end
function sfml.Ftp.get_directory_listing(self: *sfml.Ftp, directory: cstring <const>): *sfml.FtpListingResponse <cimport 'sfFtp_getDirectoryListing', nodecl> end
function sfml.Ftp.change_directory(self: *sfml.Ftp, directory: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_changeDirectory', nodecl> end
function sfml.Ftp.parent_directory(self: *sfml.Ftp): *sfml.FtpResponse <cimport 'sfFtp_parentDirectory', nodecl> end
function sfml.Ftp.create_directory(self: *sfml.Ftp, name: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_createDirectory', nodecl> end
function sfml.Ftp.delete_directory(self: *sfml.Ftp, name: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_deleteDirectory', nodecl> end
function sfml.Ftp.rename_file(self: *sfml.Ftp, file: cstring <const>, newName: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_renameFile', nodecl> end
function sfml.Ftp.delete_file(self: *sfml.Ftp, file: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_deleteFile', nodecl> end
function sfml.Ftp.download(self: *sfml.Ftp, remoteFile: cstring <const>, localPath: cstring <const>, mode: sfml.FtpTransferMode): *sfml.FtpResponse <cimport 'sfFtp_download', nodecl> end
function sfml.Ftp.upload(self: *sfml.Ftp, localFile: cstring <const>, remotePath: cstring <const>, mode: sfml.FtpTransferMode, append: sfml.Bool): *sfml.FtpResponse <cimport 'sfFtp_upload', nodecl> end
function sfml.Ftp.send_command(self: *sfml.Ftp, command: cstring <const>, parameter: cstring <const>): *sfml.FtpResponse <cimport 'sfFtp_sendCommand', nodecl> end


-- Network: HTTP
global sfml.HttpMethod: type <cimport 'sfml.HttpMethod', nodecl, using> = @enum(cint) {
  Get = 0,
  Post,
  Head,
  Put,
  Delete
}

global sfml.HttpStatus: type <cimport 'sfHttpStatus', nodecl, using> = @enum(cint) {
  Ok             = 200,
  Created        = 201,
  Accepted       = 202,
  NoContent      = 204,
  ResetContent   = 205,
  PartialContent = 206,

  MultipleChoices  = 300,
  MovedPermanently = 301,
  MovedTemporarily = 302,
  NotModified      = 304,

  BadRequest          = 400,
  Unauthorized        = 401,
  Forbidden           = 403,
  NotFound            = 404,
  RangeNotSatisfiable = 407,

  InternalServerError = 500,
  NotImplemented      = 501,
  BadGateway          = 502,
  ServiceNotAvailable = 503,
  GatewayTimeout      = 504,
  VersionNotSupported = 505,

  InvalidResponse  = 1000,
  ConnectionFailed = 1001
}

function sfml.HttpRequest.create(): *sfml.HttpRequest <cimport 'sfHttpRequest_create', nodecl> end
function sfml.HttpRequest.destroy(self: *sfml.HttpRequest): void <cimport 'sfHttpRequest_destroy', nodecl> end
function sfml.HttpRequest.set_field(self: *sfml.HttpRequest, field: cstring <const>, value: cstring <const>): void <cimport 'sfHttpRequest_setField', nodecl> end
function sfml.HttpRequest.set_method(self: *sfml.HttpRequest, method: sfml.HttpMethod): void <cimport 'sfHttpRequest_setMethod', nodecl> end
function sfml.HttpRequest.set_uri(self: *sfml.HttpRequest, uri: cstring <const>): void <cimport 'sfHttpRequest_setUri', nodecl> end
function sfml.HttpRequest.set_http_version(self: *sfml.HttpRequest, major: cuint, minor: cuint): void <cimport 'sfHttpRequest_setHttpVersion', nodecl> end
function sfml.HttpRequest.set_body(self: *sfml.HttpRequest, body: cstring <const>): void <cimport 'sfHttpRequest_setBody', nodecl> end

function sfml.HttpResponse.destroy(self: *sfml.HttpResponse): void <cimport 'sfHttpResponse_destroy', nodecl> end
function sfml.HttpResponse.get_field(self: *sfml.HttpResponse <const>, field: cstring <const>): cstring <cimport 'sfHttpResponse_getField', nodecl> end
function sfml.HttpResponse.get_status(self: *sfml.HttpResponse <const>): sfml.HttpStatus <cimport 'sfHttpResponse_getStatus', nodecl> end
function sfml.HttpResponse.get_major_version(self: *sfml.HttpResponse <const>): cuint <cimport 'sfHttpResponse_getMajorVersion', nodecl> end
function sfml.HttpResponse.get_minor_version(self: *sfml.HttpResponse <const>): cuint <cimport 'sfHttpResponse_getMinorVersion', nodecl> end
function sfml.HttpResponse.get_body(self: *sfml.HttpResponse <const>): cstring <cimport 'sfHttpResponse_getBody', nodecl> end

function sfml.Http.create(): *sfml.Http <cimport 'sfHttp_create', nodecl> end
function sfml.Http.destroy(http: *sfml.Http): void <cimport 'sfHttp_destroy', nodecl> end
function sfml.Http.set_host(http: *sfml.Http, host: cstring <const>, port: cuint): void <cimport 'sfHttp_setHost', nodecl> end
function sfml.Http.send_request(http: *sfml.Http, request: *sfml.HttpRequest <const>, timeout: sfml.Time): *sfml.HttpResponse <cimport 'sfHttp_sendRequest', nodecl> end


 -- Network: Packet
function sfml.Packet.create(): *sfml.Packet <cimport 'sfPacket_create', nodecl> end
function sfml.Packet.copy(self: *sfml.Packet <const>): *sfml.Packet <cimport 'sfPacket_copy', nodecl> end
function sfml.Packet.destroy(self: *sfml.Packet): void <cimport 'sfPacket_destroy', nodecl> end
function sfml.Packet.append(self: *sfml.Packet, data: pointer, sizeInBytes: csize): void <cimport 'sfPacket_append', nodecl> end
function sfml.Packet.clear(self: *sfml.Packet): void <cimport 'sfPacket_clear', nodecl> end
function sfml.Packet.get_data(self: *sfml.Packet <const>): pointer <cimport 'sfPacket_getData', nodecl> end
function sfml.Packet.get_data_size(self: *sfml.Packet <const>): csize <cimport 'sfPacket_getDataSize', nodecl> end
function sfml.Packet.end_of_packet(self: *sfml.Packet <const>): sfml.Bool <cimport 'sfPacket_endOfPacket', nodecl> end
function sfml.Packet.can_read(self: *sfml.Packet <const>): sfml.Bool <cimport 'sfPacket_canRead', nodecl> end

function sfml.Packet.read_bool(self: *sfml.Packet): sfml.Bool <cimport 'sfPacket_readBool', nodecl> end
function sfml.Packet.read_int8(self: *sfml.Packet): sfml.Int8 <cimport 'sfPacket_readInt8', nodecl> end
function sfml.Packet.read_uint8(self: *sfml.Packet): sfml.Uint8 <cimport 'sfPacket_readUint8', nodecl> end
function sfml.Packet.read_int16(self: *sfml.Packet): sfml.Int16 <cimport 'sfPacket_readInt16', nodecl> end
function sfml.Packet.read_uint16(self: *sfml.Packet): sfml.Uint16 <cimport 'sfPacket_readUint16', nodecl> end
function sfml.Packet.read_int32(self: *sfml.Packet): sfml.Int32 <cimport 'sfPacket_readInt32', nodecl> end
function sfml.Packet.read_uint32(self: *sfml.Packet): sfml.Uint32 <cimport 'sfPacket_readUint32', nodecl> end
function sfml.Packet.read_float(self: *sfml.Packet): float32 <cimport 'sfPacket_readFloat', nodecl> end
function sfml.Packet.read_double(self: *sfml.Packet): float64 <cimport 'sfPacket_readDouble', nodecl> end
function sfml.Packet.read_string(self: *sfml.Packet, str: cstring): void <cimport 'sfPacket_readString', nodecl> end
function sfml.Packet.read_wide_string(self: *sfml.Packet, str: *[0]cint): void <cimport 'sfPacket_readWideString', nodecl> end

function sfml.Packet.write_bool(self: *sfml.Packet, data: sfml.Bool): void <cimport 'sfPacket_writeBool', nodecl> end
function sfml.Packet.write_int8(self: *sfml.Packet, data: sfml.Int8): void <cimport 'sfPacket_writeInt8', nodecl> end
function sfml.Packet.write_uint8(self: *sfml.Packet, data: sfml.Uint8): void <cimport 'sfPacket_writeUint8', nodecl> end
function sfml.Packet.write_int16(self: *sfml.Packet, data: sfml.Int16): void <cimport 'sfPacket_writeInt16', nodecl> end
function sfml.Packet.write_uint16(self: *sfml.Packet, data: sfml.Uint16): void <cimport 'sfPacket_writeUint16', nodecl> end
function sfml.Packet.write_int32(self: *sfml.Packet, data: sfml.Int32): void <cimport 'sfPacket_writeInt32', nodecl> end
function sfml.Packet.write_uint32(self: *sfml.Packet, data: sfml.Uint32): void <cimport 'sfPacket_writeUint32', nodecl> end
function sfml.Packet.write_float(self: *sfml.Packet, data: float32): void <cimport 'sfPacket_writeFloat', nodecl> end
function sfml.Packet.write_double(self: *sfml.Packet, data: float64): void <cimport 'sfPacket_writeDouble', nodecl> end
function sfml.Packet.write_string(self: *sfml.Packet, data: cstring <const>): void <cimport 'sfPacket_writeString', nodecl> end
function sfml.Packet.write_wide_string(self: *sfml.Packet, data: *[0]cint): void <cimport 'sfPacket_writeWideString', nodecl> end


-- Network: Selector
global sfml.SocketStatus: type <cimport 'sfSocketStatus', nodecl, using> = @enum(cint) {
  Done = 0,
  NotReady,
  Partial,
  Disconnected,
  Error
}

function sfml.SocketSelector.create(): *sfml.SocketSelector <cimport 'sfSocketSelector_create', nodecl> end
function sfml.SocketSelector.copy(self: *sfml.SocketSelector <const>): *sfml.SocketSelector <cimport 'sfSocketSelector_copy', nodecl> end
function sfml.SocketSelector.destroy(self: *sfml.SocketSelector): void <cimport 'sfSocketSelector_destroy', nodecl> end
function sfml.SocketSelector.add_tcp_listener(self: *sfml.SocketSelector, socket: *sfml.TcpListener): void <cimport 'sfSocketSelector_addTcpListener', nodecl> end
function sfml.SocketSelector.add_tcp_socket(self: *sfml.SocketSelector, socket: *sfml.TcpSocket): void <cimport 'sfSocketSelector_addTcpSocket', nodecl> end
function sfml.SocketSelector.add_udp_socket(self: *sfml.SocketSelector, socket: *sfml.UdpSocket): void <cimport 'sfSocketSelector_addUdpSocket', nodecl> end
function sfml.SocketSelector.remove_tcp_listener(self: *sfml.SocketSelector, socket: *sfml.TcpListener): void <cimport 'sfSocketSelector_removeTcpListener', nodecl> end
function sfml.SocketSelector.remove_tcp_socket(self: *sfml.SocketSelector, socket: *sfml.TcpSocket): void <cimport 'sfSocketSelector_removeTcpSocket', nodecl> end
function sfml.SocketSelector.remove_udp_socket(self: *sfml.SocketSelector, socket: *sfml.UdpSocket): void <cimport 'sfSocketSelector_removeUdpSocket', nodecl> end
function sfml.SocketSelector.clear(self: *sfml.SocketSelector): void <cimport 'sfSocketSelector_clear', nodecl> end
function sfml.SocketSelector.wait(self: *sfml.SocketSelector, timeout: sfml.Time): sfml.Bool <cimport 'sfSocketSelector_wait', nodecl> end
function sfml.SocketSelector.is_tcp_listener_ready(self: *sfml.SocketSelector <const>, socket: *sfml.TcpListener): void <cimport 'sfSocketSelector_isTcpListenerReady', nodecl> end
function sfml.SocketSelector.is_tcp_socket_ready(self: *sfml.SocketSelector <const>, socket: *sfml.TcpSocket): void <cimport 'sfSocketSelector_isTcpSocketReady', nodecl> end
function sfml.SocketSelector.is_udp_socket_ready(self: *sfml.SocketSelector <const>, socket: *sfml.UdpSocket): void <cimport 'sfSocketSelector_isUdpSocketReady', nodecl> end

function sfml.TcpListener.create(): *sfml.TcpListener <cimport 'sfTcpListener_create', nodecl> end
function sfml.TcpListener.destroy(self: *sfml.TcpListener): void <cimport 'sfTcpListener_destroy', nodecl> end
function sfml.TcpListener.set_blocking(self: *sfml.TcpListener, blocking: sfml.Bool): void <cimport 'sfTcpListener_setBlocking', nodecl> end
function sfml.TcpListener.is_blocking(self: *sfml.TcpListener <const>): sfml.Bool <cimport 'sfTcpListener_isBlocking', nodecl> end
function sfml.TcpListener.get_local_port(self: *sfml.TcpListener <const>): cushort <cimport 'sfTcpListener_getLocalPort', nodecl> end
function sfml.TcpListener.listen(self: *sfml.TcpListener <const>, port: cushort, address: sfml.IpAddress): sfml.SocketStatus <cimport 'sfTcpListener_listen', nodecl> end
function sfml.TcpListener.accept(self: *sfml.TcpListener <const>, connected: *[0]*sfml.TcpSocket): sfml.SocketStatus <cimport 'sfTcpListener_accept', nodecl> end

function sfml.TcpSocket.create(): *sfml.TcpSocket <cimport 'sfTcpSocket_create', nodecl> end
function sfml.TcpSocket.destroy(self: *sfml.TcpSocket): void <cimport 'sfTcpSocket_destroy', nodecl> end
function sfml.TcpSocket.set_blocking(self: *sfml.TcpSocket, blocking: sfml.Bool): void <cimport 'sfTcpSocket_setBlocking', nodecl> end
function sfml.TcpSocket.is_blocking(self: *sfml.TcpSocket <const>): sfml.Bool <cimport 'sfTcpSocket_isBlocking', nodecl> end
function sfml.TcpSocket.get_local_port(self: *sfml.TcpSocket <const>): cushort <cimport 'sfTcpSocket_getLocalPort', nodecl> end
function sfml.TcpSocket.get_remote_address(self: *sfml.TcpSocket <const>): sfml.IpAddress <cimport 'sfTcpSocket_getRemoteAddress', nodecl> end
function sfml.TcpSocket.get_remote_port(self: *sfml.TcpSocket <const>): cushort <cimport 'sfTcpSocket_getRemotePort', nodecl> end
function sfml.TcpSocket.connect(self: *sfml.TcpSocket, remoteAddress: sfml.IpAddress, remotePort: cushort, timeout: sfml.Time): sfml.SocketStatus <cimport 'sfTcpSocket_connect', nodecl> end
function sfml.TcpSocket.disconnect(self: *sfml.TcpSocket): void <cimport 'sfTcpSocket_disconnect', nodecl> end
function sfml.TcpSocket.send(self: *sfml.TcpSocket, data: pointer <const>, size: csize): sfml.SocketStatus <cimport 'sfTcpSocket_send', nodecl> end
function sfml.TcpSocket.send_partial(self: *sfml.TcpSocket, data: pointer <const>, size: csize, received: *csize): sfml.SocketStatus <cimport 'sfTcpSocket_sendPartial', nodecl> end
function sfml.TcpSocket.receive(self: *sfml.TcpSocket, data: pointer <const>, size: csize, received: *csize): sfml.SocketStatus <cimport 'sfTcpSocket_receive', nodecl> end
function sfml.TcpSocket.send_packet(self: *sfml.TcpSocket, packet: *sfml.Packet): sfml.SocketStatus <cimport 'sfTcpSocket_sendPacket', nodecl> end
function sfml.TcpSocket.receive_packet(self: *sfml.TcpSocket, packet: *sfml.Packet): sfml.SocketStatus <cimport 'sfTcpSocket_receivePacket', nodecl> end

function sfml.UdpSocket.create(): *sfml.UdpSocket <cimport 'sfUdpSocket_create', nodecl> end
function sfml.UdpSocket.destroy(self: *sfml.UdpSocket): void <cimport 'sfUdpSocket_destroy', nodecl> end
function sfml.UdpSocket.set_blocking(self: *sfml.UdpSocket, blocking: sfml.Bool): void <cimport 'sfUdpSocket_setBlocking', nodecl> end
function sfml.UdpSocket.is_blocking(self: *sfml.UdpSocket <const>): sfml.Bool <cimport 'sfUdpSocket_isBlocking', nodecl> end
function sfml.UdpSocket.get_local_port(self: *sfml.UdpSocket <const>): cushort <cimport 'sfUdpSocket_getLocalPort', nodecl> end
function sfml.UdpSocket.bind(self: *sfml.UdpSocket <const>, port: cushort, address: sfml.IpAddress): sfml.SocketStatus <cimport 'sfUdpSocket_bind', nodecl> end
function sfml.UdpSocket.unbind(self: *sfml.UdpSocket): void <cimport 'sfUdpSocket_unbind', nodecl> end
function sfml.UdpSocket.send(self: *sfml.UdpSocket, data: pointer<const>, size: csize, remoteAddress: sfml.IpAddress, remotePort: cushort): sfml.SocketStatus <cimport 'sfUdpSocket_send', nodecl> end
function sfml.UdpSocket.receive(self: *sfml.UdpSocket, data: pointer, size: csize, received: *csize, remoteAddress: *sfml.IpAddress, remotePort: *cushort): sfml.SocketStatus <cimport 'sfUdpSocket_receive', nodecl> end
function sfml.UdpSocket.send_packet(self: *sfml.UdpSocket, packet: *sfml.Packet, remoteAddress: sfml.IpAddress, remotePort: cushort): sfml.SocketStatus <cimport 'sfUdpSocket_sendPacket', nodecl> end
function sfml.UdpSocket.receive_packet(self: *sfml.UdpSocket, packet: *sfml.Packet, remoteAddress: *sfml.IpAddress, remotePort: *cushort): sfml.SocketStatus <cimport 'sfUdpSocket_receivePacket', nodecl> end
function sfml.UdpSocket.max_datagram_size(): cuint <cimport 'sfUdpSocket_maxDatagramSize', nodecl> end


-- Audio
global sfml.SoundStatus: type <cimport 'sfSoundStatus', nodecl, using> = @enum(cint) {
  Stopped = 0,
  Paused,
  Playing
}

global sfml.TimeSpan: type <cimport 'sfTimeSpan', nodecl> = @record {
  offset: sfml.Time,
  length: sfml.Time
}

-- Audio: Listener
global sfml.Listener = @record{}
function sfml.Listener.set_global_volume(volume: float32): void <cimport 'sfListener_setGlobalVolume', nodecl> end
function sfml.Listener.get_global_volume(): float32 <cimport 'sfListener_getGlobalVolume', nodecl> end
function sfml.Listener.set_position(position: sfml.Vector3f): void <cimport 'sfListener_setPosition', nodecl> end
function sfml.Listener.get_position(): sfml.Vector3f <cimport 'sfListener_getPosition', nodecl> end
function sfml.Listener.set_direction(direction: sfml.Vector3f): void <cimport 'sfListener_setDirection', nodecl> end
function sfml.Listener.get_direction(): sfml.Vector3f <cimport 'sfListener_getDirection', nodecl> end
function sfml.Listener.set_up_vector(upVector: sfml.Vector3f): void <cimport 'sfListener_setUpVector', nodecl> end
function sfml.Listener.get_up_vector(): sfml.Vector3f <cimport 'sfListener_getUpVector', nodecl> end


-- Audio: Music
global sfml.Music: type <cimport 'sfMusic', nodecl, forwarddecl> = @record {}
global sfml.Sound: type <cimport 'sfSound', nodecl, forwarddecl> = @record {}
global sfml.SoundBuffer: type <cimport 'sfSoundBuffer', nodecl, forwarddecl> = @record {}
global sfml.SoundBufferRecorder: type <cimport 'sfSoundBufferRecorder', nodecl, forwarddecl> = @record {}
global sfml.SoundRecorder: type <cimport 'sfSoundRecorder', nodecl, forwarddecl> = @record {}
global sfml.SoundStream: type <cimport 'sfSoundStream', nodecl, forwarddecl> = @record {}

function sfml.Music.create_from_file(filename: cstring <const>): *sfml.Music <cimport 'sfMusic_createFromFile', nodecl> end
function sfml.Music.create_from_memory(data: pointer <const>, sizeInBytes: csize): *sfml.Music <cimport 'sfMusic_createFromMemory', nodecl> end
function sfml.Music.create_from_stream(stream: *sfml.InputStream): *sfml.Music <cimport 'sfMusic_createFromStream', nodecl> end
function sfml.Music.destroy(self: *sfml.Music): void <cimport 'sfMusic_destroy', nodecl> end
function sfml.Music.get_loop(self: *sfml.Music <const>): sfml.Bool <cimport 'sfMusic_getLoop', nodecl> end
function sfml.Music.set_loop(self: *sfml.Music, loop: sfml.Bool): void <cimport 'sfMusic_setLoop', nodecl> end
function sfml.Music.get_duration(self: *sfml.Music <const>): sfml.Time <cimport 'sfMusic_getDuration', nodecl> end
function sfml.Music.get_loop_points(self: *sfml.Music <const>): sfml.TimeSpan <cimport 'sfMusic_getLoopPoints', nodecl> end
function sfml.Music.set_loop_points(self: *sfml.Music, timePoints: sfml.TimeSpan): void <cimport 'sfMusic_setLoopPoints', nodecl> end
function sfml.Music.play(self: *sfml.Music): void <cimport 'sfMusic_play', nodecl> end
function sfml.Music.pause(self: *sfml.Music): void <cimport 'sfMusic_pause', nodecl> end
function sfml.Music.stop(self: *sfml.Music): void <cimport 'sfMusic_stop', nodecl> end
function sfml.Music.get_channel_count(self: *sfml.Music <const>): cuint <cimport 'sfMusic_getChannelCount', nodecl> end
function sfml.Music.get_sample_rate(self: *sfml.Music <const>): cuint <cimport 'sfMusic_getSampleRate', nodecl> end
function sfml.Music.get_status(self: *sfml.Music <const>): sfml.SoundStatus <cimport 'sfMusic_getStatus', nodecl> end
function sfml.Music.get_playing_offset(self: *sfml.Music <const>): sfml.Time <cimport 'sfMusic_getPlayingOffset', nodecl> end
function sfml.Music.set_playing_offset(self: *sfml.Music, timeOffset: sfml.Time): void <cimport 'sfMusic_setPlayingOffset', nodecl> end
function sfml.Music.get_pitch(self: *sfml.Music <const>): float32 <cimport 'sfMusic_getPitch', nodecl> end
function sfml.Music.set_pitch(self: *sfml.Music, pitch: float32): void <cimport 'sfMusic_setPitch', nodecl> end
function sfml.Music.get_volume(self: *sfml.Music <const>): float32 <cimport 'sfMusic_getVolume', nodecl> end
function sfml.Music.set_volume(self: *sfml.Music, volume: float32): void <cimport 'sfMusic_setVolume', nodecl> end
function sfml.Music.get_position(self: *sfml.Music <const>): sfml.Vector3f <cimport 'sfMusic_getPosition', nodecl> end
function sfml.Music.set_position(self: *sfml.Music, position: sfml.Vector3f): void <cimport 'sfMusic_setPosition', nodecl> end
function sfml.Music.set_relative_to_listener(music: *sfml.Music, relative: sfml.Bool): void <cimport 'sfMusic_setRelativeToListener', nodecl> end
function sfml.Music.get_min_distance(self: *sfml.Music <const>): float32 <cimport 'sfMusic_getMinDistance', nodecl> end
function sfml.Music.set_min_distance(self: *sfml.Music, distance: float32): void <cimport 'sfMusic_setMinDistance', nodecl> end
function sfml.Music.get_attenuation(self: *sfml.Music <const>): float32 <cimport 'sfMusic_getAttenuation', nodecl> end
function sfml.Music.set_attenuation(self: *sfml.Music, attenuation: float32): void <cimport 'sfMusic_setAttenuation', nodecl> end
function sfml.Music.is_relative_to_listener(self: *sfml.Music <const>): sfml.Bool <cimport 'sfMusic_isRelativeToListener', nodecl> end


-- Audio: Sound
function sfml.Sound.create(): *sfml.Sound <cimport 'sfSound_create', nodecl> end
function sfml.Sound.copy(self: *sfml.Sound <const>): *sfml.Sound <cimport 'sfSound_copy', nodecl> end
function sfml.Sound.destroy(self: *sfml.Sound): void <cimport 'sfSound_destroy', nodecl> end
function sfml.Sound.play(self: *sfml.Sound): void <cimport 'sfSound_play', nodecl> end
function sfml.Sound.pause(self: *sfml.Sound): void <cimport 'sfSound_pause', nodecl> end
function sfml.Sound.stop(self: *sfml.Sound): void <cimport 'sfSound_stop', nodecl> end
function sfml.Sound.get_buffer(self: *sfml.Sound <const>): *sfml.SoundBuffer <cimport 'sfSound_getBuffer', nodecl> end
function sfml.Sound.set_buffer(self: *sfml.Sound, buffer: *sfml.SoundBuffer <const>): void <cimport 'sfSound_setBuffer', nodecl> end
function sfml.Sound.set_loop(self: *sfml.Sound, loop: sfml.Bool): void <cimport 'sfSound_setLoop', nodecl> end
function sfml.Sound.get_loop(self: *sfml.Sound <const>): sfml.Bool <cimport 'sfSound_getLoop', nodecl> end
function sfml.Sound.get_status(self: *sfml.Sound <const>): sfml.SoundStatus <cimport 'sfSound_getStatus', nodecl> end
function sfml.Sound.get_pitch(self: *sfml.Sound <const>): float32 <cimport 'sfSound_getPitch', nodecl> end
function sfml.Sound.set_pitch(self: *sfml.Sound, pitch: float32): void <cimport 'sfSound_setPitch', nodecl> end
function sfml.Sound.get_volume(self: *sfml.Sound <const>): float32 <cimport 'sfSound_getVolume', nodecl> end
function sfml.Sound.set_volume(self: *sfml.Sound, volume: float32): void <cimport 'sfSound_setVolume', nodecl> end
function sfml.Sound.get_position(self: *sfml.Sound <const>): sfml.Vector3f <cimport 'sfSound_getPosition', nodecl> end
function sfml.Sound.set_position(self: *sfml.Sound, position: sfml.Vector3f): void <cimport 'sfSound_setPosition', nodecl> end
function sfml.Sound.get_min_distance(self: *sfml.Sound <const>): float32 <cimport 'sfSound_getMinDistance', nodecl> end
function sfml.Sound.set_min_distance(self: *sfml.Sound, distance: float32): void <cimport 'sfSound_setMinDistance', nodecl> end
function sfml.Sound.get_attenuation(self: *sfml.Sound <const>): float32 <cimport 'sfSound_getAttenuation', nodecl> end
function sfml.Sound.set_attenuation(self: *sfml.Sound, attenuation: float32): void <cimport 'sfSound_setAttenuation', nodecl> end
function sfml.Sound.get_playing_offset(self: *sfml.Sound <const>): sfml.Time <cimport 'sfSound_getPlayingOffset', nodecl> end
function sfml.Sound.set_playing_offset(self: *sfml.Sound, timeOffset: sfml.Time): void <cimport 'sfSound_setPlayingOffset', nodecl> end
function sfml.Sound.set_relative_to_listener(self: *sfml.Sound, relative: sfml.Bool): void <cimport 'sfSound_setRelativeToListener', nodecl> end
function sfml.Sound.is_relative_to_listener(self: *sfml.Sound <const>): sfml.Bool <cimport 'sfSound_isRelativeToListener', nodecl> end


-- Audio: Sound Buffer
function sfml.SoundBuffer.create_from_file(filename: cstring <const>): *sfml.SoundBuffer <cimport 'sfSoundBuffer_createFromFile', nodecl> end
function sfml.SoundBuffer.create_from_memory(data: pointer <const>, sizeInBytes: csize): *sfml.SoundBuffer <cimport 'sfSoundBuffer_createFromMemory', nodecl> end
function sfml.SoundBuffer.create_from_stream(stream: *sfml.InputStream): *sfml.SoundBuffer <cimport 'sfSoundBuffer_createFromStream', nodecl> end
function sfml.SoundBuffer.create_from_samples(samples: *[0]sfml.Int16, sampleCount: sfml.Uint64, channelCount: cuint, sampleRate: cuint): *sfml.SoundBuffer <cimport 'sfSoundBuffer_createFromSamples', nodecl> end
function sfml.SoundBuffer.copy(self: *sfml.SoundBuffer <const>): *sfml.SoundBuffer <cimport 'sfSoundBuffer_copy', nodecl> end
function sfml.SoundBuffer.destroy(self: *sfml.SoundBuffer): void <cimport 'sfSoundBuffer_destroy', nodecl> end
function sfml.SoundBuffer.save_to_file(self: *sfml.SoundBuffer <const>, filename: cstring <const>): sfml.Bool <cimport 'sfSoundBuffer_saveToFile', nodecl> end
function sfml.SoundBuffer.get_samples(self: *sfml.SoundBuffer <const>): *[0]sfml.Int16 <cimport 'sfSoundBuffer_getSamples', nodecl> end
function sfml.SoundBuffer.get_sample_count(self: *sfml.SoundBuffer <const>): sfml.Uint64 <cimport 'sfSoundBuffer_getSampleCount', nodecl> end
function sfml.SoundBuffer.get_sample_rate(self: *sfml.SoundBuffer <const>): cuint <cimport 'sfSoundBuffer_getSampleRate', nodecl> end
function sfml.SoundBuffer.get_channel_count(self: *sfml.SoundBuffer <const>): cuint <cimport 'sfSoundBuffer_getChannelCount', nodecl> end
function sfml.SoundBuffer.get_duration(self: *sfml.SoundBuffer <const>): sfml.Time <cimport 'sfSoundBuffer_getDuration', nodecl> end


-- Audio: Sound Buffer Recorder
function sfml.SoundBufferRecorder.create(): *sfml.SoundBufferRecorder <cimport 'sfSoundBufferRecorder_create', nodecl> end
function sfml.SoundBufferRecorder.destroy(self: *sfml.SoundBufferRecorder): void <cimport 'sfSoundBufferRecorder_destroy', nodecl> end
function sfml.SoundBufferRecorder.start(self: *sfml.SoundBufferRecorder, sampleRate: cuint): sfml.Bool <cimport 'sfSoundBufferRecorder_start', nodecl> end
function sfml.SoundBufferRecorder.stop(self: *sfml.SoundBufferRecorder): void <cimport 'sfSoundBufferRecorder_stop', nodecl> end
function sfml.SoundBufferRecorder.get_sample_rate(self: *sfml.SoundBufferRecorder <const>): cuint <cimport 'sfSoundBufferRecorder_getSampleRate', nodecl> end
function sfml.SoundBufferRecorder.get_buffer(self: *sfml.SoundBufferRecorder <const>): *sfml.SoundBuffer <cimport 'sfSoundBufferRecorder_getBuffer', nodecl> end
function sfml.SoundBufferRecorder.set_device(self: *sfml.SoundBufferRecorder <const>, name: cstring <const>): sfml.Bool <cimport 'sfSoundBufferRecorder_setDevice', nodecl> end
function sfml.SoundBufferRecorder.get_device(self: *sfml.SoundBufferRecorder): cstring <cimport 'sfSoundBufferRecorder_getDevice', nodecl> end


global sfml.SoundRecorderStartCallback: type <cimport 'sfSoundRecorderStartCallback', nodecl> = @function(pointer): sfml.Bool
global sfml.SoundRecorderProcessCallback: type <cimport 'sfSoundRecorderProcessCallback', nodecl> = @function(*[0]sfml.Int16, csize, pointer): sfml.Bool
global sfml.SoundRecorderStopCallback: type <cimport 'sfSoundRecorderStopCallback', nodecl> = @function(pointer): void


-- Audio: Sound Recorder
function sfml.SoundRecorder.create(onStart: sfml.SoundRecorderStartCallback, onProcess: sfml.SoundRecorderProcessCallback, onStop: sfml.SoundRecorderStopCallback, userData: pointer): *sfml.SoundRecorder <cimport 'sfSoundRecorder_create', nodecl> end
function sfml.SoundRecorder.destroy(self: *sfml.SoundRecorder): void <cimport 'sfSoundRecorder_destroy', nodecl> end
function sfml.SoundRecorder.start(self: *sfml.SoundRecorder, sampleRate: cuint): sfml.Bool <cimport 'sfSoundRecorder_start', nodecl> end
function sfml.SoundRecorder.stop(self: *sfml.SoundRecorder): void <cimport 'sfSoundRecorder_stop', nodecl> end
function sfml.SoundRecorder.get_sample_rate(self: *sfml.SoundRecorder <const>): cuint <cimport 'sfSoundRecorder_getSampleRate', nodecl> end
function sfml.SoundRecorder.is_available(): sfml.Bool <cimport 'sfSoundRecorder_isAvailable', nodecl> end
function sfml.SoundRecorder.set_processing_interval(self: *sfml.SoundRecorder, interval: sfml.Time): void <cimport 'sfSoundRecorder_setProcessingInterval', nodecl> end
function sfml.SoundRecorder.get_available_devices(count: csize): *[0]cstring <cimport 'sfSoundRecorder_getAvailableDevices', nodecl> end
function sfml.SoundRecorder.get_default_device(): cstring <cimport 'sfSoundRecorder_getDefaultDevice', nodecl> end
function sfml.SoundRecorder.get_device(self: *sfml.SoundRecorder): cstring <cimport 'sfSoundRecorder_getDevice', nodecl> end
function sfml.SoundRecorder.set_device(self: *sfml.SoundRecorder, name: cstring <const>): sfml.Bool <cimport 'sfSoundRecorder_setDevice', nodecl> end
function sfml.SoundRecorder.get_channel_count(self: *sfml.SoundRecorder <const>): cuint <cimport 'sfSoundRecorder_getChannelCount', nodecl> end
function sfml.SoundRecorder.set_channel_count(self: *sfml.SoundRecorder, channelCount: cuint): void <cimport 'sfSoundRecorder_setChannelCount', nodecl> end


-- Audio: SoundStream
global sfml.SoundStreamChunk: type <cimport 'sfSoundStreamChunk', nodecl> = @record {
  samples: *[0]sfml.Int16,
  sampleCount: cuint
}

global sfml.SoundStreamGetDataCallback: type <cimport 'sfSoundStreamGetDataCallback', nodecl> = @function(*sfml.SoundStreamChunk, pointer): sfml.Bool
global sfml.SoundStreamSeekCallback: type <cimport 'sfSoundStreamSeekCallback', nodecl> = @function(sfml.Time, pointer): void

function sfml.SoundStream.create(onGetData: sfml.SoundStreamGetDataCallback, onSeek: sfml.SoundStreamSeekCallback, channelCount: cuint, sampleRate: cuint, userData: pointer): *sfml.SoundStream <cimport 'sfSoundStream_create', nodecl> end
function sfml.SoundStream.destroy(self: *sfml.SoundStream): void <cimport 'sfSoundStream_destroy', nodecl> end
function sfml.SoundStream.play(self: *sfml.SoundStream): void <cimport 'sfSoundStream_play', nodecl> end
function sfml.SoundStream.pause(self: *sfml.SoundStream): void <cimport 'sfSoundStream_pause', nodecl> end
function sfml.SoundStream.stop(self: *sfml.SoundStream): void <cimport 'sfSoundStream_stop', nodecl> end
function sfml.SoundStream.get_status(self: *sfml.SoundStream <const>): sfml.SoundStatus <cimport 'sfSoundStream_getStatus', nodecl> end
function sfml.SoundStream.get_channel_count(self: *sfml.SoundStream <const>): cuint <cimport 'sfSoundStream_getChannelCount', nodecl> end
function sfml.SoundStream.get_pitch(self: *sfml.SoundStream <const>): float32 <cimport 'sfSoundStream_getPitch', nodecl> end
function sfml.SoundStream.set_pitch(self: *sfml.SoundStream, pitch: float32): void <cimport 'sfSoundStream_setPitch', nodecl> end
function sfml.SoundStream.get_volume(self: *sfml.SoundStream <const>): float32 <cimport 'sfSoundStream_getVolume', nodecl> end
function sfml.SoundStream.set_volume(self: *sfml.SoundStream, volume: float32): void <cimport 'sfSoundStream_setVolume', nodecl> end
function sfml.SoundStream.get_position(self: *sfml.SoundStream <const>): sfml.Vector3f <cimport 'sfSoundStream_getPosition', nodecl> end
function sfml.SoundStream.set_position(self: *sfml.SoundStream, position: sfml.Vector3f): void <cimport 'sfSoundStream_setPosition', nodecl> end
function sfml.SoundStream.get_min_distance(self: *sfml.SoundStream <const>): float32 <cimport 'sfSoundStream_getMinDistance', nodecl> end
function sfml.SoundStream.set_min_distance(self: *sfml.SoundStream, distance: float32): void <cimport 'sfSoundStream_setMinDistance', nodecl> end
function sfml.SoundStream.get_playing_offset(self: *sfml.SoundStream <const>): sfml.Time <cimport 'sfSoundStream_getPlayingOffset', nodecl> end
function sfml.SoundStream.set_playing_offset(self: *sfml.SoundStream, timeOffset: sfml.Time): void <cimport 'sfSoundStream_setPlayingOffset', nodecl> end
function sfml.SoundStream.get_loop(self: *sfml.SoundStream <const>): sfml.Bool <cimport 'sfSoundStream_getLoop', nodecl> end
function sfml.SoundStream.set_loop(self: *sfml.SoundStream, loop: sfml.Bool): void <cimport 'sfSoundStream_setLoop', nodecl> end
function sfml.SoundStream.get_attenuation(self: *sfml.SoundStream <const>): float32 <cimport 'sfSoundStream_getAttenuation', nodecl> end
function sfml.SoundStream.set_attenuation(self: *sfml.SoundStream, attenuation: float32): void <cimport 'sfSoundStream_setAttenuation', nodecl> end
function sfml.SoundStream.is_relative_to_listener(self: *sfml.SoundStream <const>): sfml.Bool <cimport 'sfSoundStream_isRelativeToListener', nodecl> end
function sfml.SoundStream.set_relative_to_listener(self: *sfml.SoundStream, relative: sfml.Bool): void <cimport 'sfSoundStream_setRelativeToListener', nodecl> end


-- Clipboard
global sfml.Context: type <cimport 'sfContext', nodecl, forwarddecl> = @record {}
global sfml.Cursor: type <cimport 'sfCursor', nodecl, forwarddecl> = @record {}
global sfml.Window: type <cimport 'sfWindow', nodecl, forwarddecl> = @record {}

global sfml.Clipboard = @record{}
function sfml.Clipboard.get_string(): cstring <cimport 'sfClipboard_getString', nodecl> end
function sfml.Clipboard.get_unicode_string(): *[0]sfml.Uint32 <cimport 'sfClipboard_getUnicodeString', nodecl> end
function sfml.Clipboard.set_string(text: cstring <const>): void <cimport 'sfClipboard_setString', nodecl> end
function sfml.Clipboard.set_unicode_string(text: *[0]sfml.Uint32): void <cimport 'sfClipboard_setUnicodeString', nodecl> end


## if ccinfo.is_apple then
global sfml.WindowHandle: type <cimport, nodecl> = @culong
## else
global sfml.WindowHandle: type <cimport, nodecl> = @pointer
## end


-- Video Mode
global sfml.VideoMode: type <cimport 'sfVideoMode', nodecl> = @record {
  width: cuint,
  height: cuint,
  bitsPerPixel: cuint
}

function sfml.VideoMode.get_desktop_mode(): sfml.VideoMode <cimport 'sfVideoMode_getDesktopMode', nodecl> end
function sfml.VideoMode.get_fullscreen_modes(count: *csize): *[0]sfml.VideoMode <cimport 'sfVideoMode_getFullscreenModes', nodecl> end
function sfml.VideoMode.is_valid(mode: sfml.VideoMode): sfml.Bool <cimport 'sfVideoMode_isValid', nodecl> end


-- Control: Joystick
global sfml.JoystickIdentification: type <cimport 'sfJoystickIdentification', nodecl> = @record {
  name: cstring,
  vendorId: cuint,
  productId: cuint
}

global sfml.JoystickCount: cint <cimport 'sfJoystickCount', nodecl, const>
global sfml.JoystickButtonCount: cint <cimport 'sfJoystickButtonCount', nodecl, const>
global sfml.JoystickAxisCount: cint <cimport 'sfJoystickAxisCount', nodecl, const>

global sfml.JoystickAxis: type <cimport 'sfJoystickAxis', nodecl, using> = @enum(cint) {
  X = 0,
  Y,
  Z,
  R,
  U,
  V,
  PovX,
  PovY
}

global sfml.Joystick = @record{}
function sfml.Joystick.is_connected(joystick: cuint): sfml.Bool <cimport 'sfJoystick_isConnected', nodecl> end
function sfml.Joystick.get_button_count(joystick: cuint): cuint <cimport 'sfJoystick_getButtonCount', nodecl> end
function sfml.Joystick.has_axis(joystick: cuint, axis: sfml.JoystickAxis): sfml.Bool <cimport 'sfJoystick_hasAxis', nodecl> end
function sfml.Joystick.is_button_pressed(joystick: cuint, button: cuint): sfml.Bool <cimport 'sfJoystick_isButtonPressed', nodecl> end
function sfml.Joystick.get_axis_position(joystick: cuint, axis: sfml.JoystickAxis): float32 <cimport 'sfJoystick_getAxisPosition', nodecl> end
function sfml.Joystick.get_identification(joystick: cuint): sfml.JoystickIdentification <cimport 'sfJoystick_getIdentification', nodecl> end
function sfml.Joystick.update(): void <cimport 'sfJoystick_update', nodecl> end


-- Control: Key
global sfml.KeyCode: type <cimport 'sfKeyCode', nodecl, using> = @enum(cint) {
  Unknown = -1,
  A,
  B,
  C,
  D,
  E,
  F,
  G,
  H,
  I,
  J,
  K,
  L,
  M,
  N,
  O,
  P,
  Q,
  R,
  S,
  T,
  U,
  V,
  W,
  X,
  Y,
  Z,
  Num0,
  Num1,
  Num2,
  Num3,
  Num4,
  Num5,
  Num6,
  Num7,
  Num8,
  Num9,
  Escape,
  LControl,
  LShift,
  LAlt,
  LSystem,
  RControl,
  RShift,
  RAlt,
  RSystem,
  Menu,
  LBracket,
  RBracket,
  Semicolon,
  Comma,
  Period,
  Quote,
  Slash,
  Backslash,
  Tilde,
  Equal,
  Hyphen,
  Space,
  Enter,
  Backspace,
  Tab,
  PageUp,
  PageDown,
  End,
  Home,
  Insert,
  Delete,
  Add,
  Subtract,
  Multiply,
  Divide,
  Left,
  Right,
  Up,
  Down,
  Numpad0,
  Numpad1,
  Numpad2,
  Numpad3,
  Numpad4,
  Numpad5,
  Numpad6,
  Numpad7,
  Numpad8,
  Numpad9,
  F1,
  F2,
  F3,
  F4,
  F5,
  F6,
  F7,
  F8,
  F9,
  F10,
  F11,
  F12,
  F13,
  F14,
  F15,
  Pause,
  Count
}

global sfml.KeyDash: cint <cimport 'sfKeyDash', nodecl, const>
global sfml.KeyBack: cint <cimport 'sfKeyBack', nodecl, const>
global sfml.KeyBackSlash: cint <cimport 'sfKeyBackSlash', nodecl, const>
global sfml.KeySemiColon: cint <cimport 'sfKeySemiColon', nodecl, const>
global sfml.KeyReturn: cint <cimport 'sfKeyReturn', nodecl, const>

global sfml.Keyboard = @record{}
function sfml.Keyboard.is_key_pressed(key: sfml.KeyCode): sfml.Bool <cimport 'sfKeyboard_isKeyPressed', nodecl> end
function sfml.Keyboard.set_virtual_keyboard_visible(visible: sfml.Bool): void <cimport 'sfKeyboard_setVirtualKeyboardVisible', nodecl> end


-- Control: Mouse
global sfml.MouseButton: type <cimport 'sfMouseButton', nodecl, using> = @enum(cint) {
  Left = 0,
  Right,
  Middle,
  XButton1,
  XButton2,
  ButtonCount,
}

global sfml.MouseWheel: type <cimport 'sfMouseWheel', nodecl, using> = @enum(cint) {
  VerticalWheel = 0,
  HorizontalWheel
}

global sfml.Mouse = @record{}
function sfml.Mouse.is_button_pressed(button: sfml.MouseButton): sfml.Bool <cimport 'sfMouse_isButtonPressed', nodecl> end
function sfml.Mouse.get_position(relativeTo: *sfml.Window <const>): sfml.Vector2i <cimport 'sfMouse_getPosition', nodecl> end
function sfml.Mouse.set_position(position: sfml.Vector2i, relativeTo: *sfml.Window <const>): void <cimport 'sfMouse_setPosition', nodecl> end

global sfml.CursorType: type <cimport 'sfCursorType', nodecl, using> = @enum(cint) {
  Arrow = 0,
  ArrowWait,
  Wait,
  Text,
  Hand,
  SizeHorizontal,
  SizeVertical,
  SizeTopLeftBottomRight,
  SizeBottomLeftTopRight,
  SizeAll,
  Cross,
  Help,
  NotAllowed
}

function sfml.Cursor.create_from_pixels(pixels: *[0]sfml.Uint8 <const>, size: sfml.Vector2u, hotspot: sfml.Vector2u): *sfml.Cursor <cimport 'sfCursor_createFromPixels', nodecl> end
function sfml.Cursor.create_from_system(cursor_type: sfml.CursorType): *sfml.Cursor <cimport, nodecl> end
function sfml.Cursor.destroy(cursor: *sfml.Cursor): void <cimport, nodecl> end


-- Contol: Sensor
global sfml.SensorType: type <cimport 'sfSensorType', nodecl, using> = @enum(cint) {
  Accelerometer = 0,
  Gyroscope,
  Magnetometer,
  Gravity,
  Orientation,
  Count
}

global sfml.Sensor = @record{}
function sfml.Sensor.is_available(sensor: sfml.SensorType): sfml.Bool <cimport 'sfSensor_isAvailable', nodecl> end
function sfml.Sensor.set_enabled(sensor: sfml.SensorType, enabled: sfml.Bool): void <cimport 'sfSensor_setEnabled', nodecl> end
function sfml.Sensor.get_value(sensor: sfml.SensorType): sfml.Vector3f <cimport 'sfSensor_getValue', nodecl> end

global sfml.Touch = @record{}
function sfml.Touch.is_down(finger: cuint): sfml.Bool <cimport 'sfTouch_isDown', nodecl> end
function sfml.Touch.get_position(finger: cuint, relativeTo: *sfml.Window <const>): sfml.Vector2i <cimport 'sfTouch_getPosition', nodecl> end


-- Event
global sfml.EventType: type <cimport 'sfEventType', nodecl, using> = @enum(cint) {
  Closed = 0,
  Resized,
  LostFocus,
  GainedFocus,
  TextEntered,
  KeyPressed,
  KeyReleased,
  MouseWheelMoved,
  MouseWheelScrolled,
  MouseButtonPressed,
  MouseButtonReleased,
  MouseMoved,
  MouseEntered,
  KeyPressed,
  KeyReleased,
  MouseWheelMoved,
  MouseWheelScrolled,
  MouseButtonPressed,
  MouseButtonReleased,
  MouseMoved,
  MouseEntered,
  MouseLeft,
  JoystickButtonPressed,
  JoystickButtonReleased,
  JoystickMoved,
  JoystickConnected,
  JoystickDisconnected,
  TouchBegan,
  TouchMoved,
  TouchEnded,
  SensorChanged,
  Count
}

global sfml.KeyEvent: type <cimport 'sfKeyEvent', nodecl> = @record {
  type: sfml.EventType,
  code: sfml.KeyCode,
  alt: sfml.Bool,
  control: sfml.Bool,
  shift: sfml.Bool,
  system: sfml.Bool
}

global sfml.TextEvent: type <cimport 'sfTextEvent', nodecl> = @record {
  type: sfml.EventType,
  unicode: sfml.Uint32
}

global sfml.MouseMoveEvent: type <cimport 'sfMouseMoveEvent', nodecl> = @record {
  type: sfml.EventType,
  x: cint,
  y: cint
}

global sfml.MouseButtonEvent: type <cimport 'sfMouseButtonEvent', nodecl> = @record {
  type: sfml.EventType,
  button: sfml.MouseButton,
  x: cint,
  y: cint
}

global sfml.MouseWheelEvent: type <cimport 'sfMouseWheelEvent', nodecl> = @record {
  type: sfml.EventType,
  delta: cint,
  x: cint,
  y: cint
}

global sfml.MouseWheelScrollEvent: type <cimport 'sfMouseWheelScrollEvent', nodecl> = @record {
  type: sfml.EventType,
  wheel: sfml.MouseWheel,
  delta: cint,
  x: cint,
  y: cint
}

global sfml.JoystickMoveEvent: type <cimport 'sfJoystickMoveEvent', nodecl> = @record {
  type: sfml.EventType,
  joystickId: cuint,
  axis: sfml.JoystickAxis,
  position: float32
}

global sfml.JoystickButtonEvent: type <cimport 'sfJoystickButtonEvent', nodecl> = @record {
  type: sfml.EventType,
  joystickId: cuint,
  button: cuint
}

global sfml.JoystickConnectEvent: type <cimport 'sfJoystickConnectEvent', nodecl> = @record {
  type: sfml.EventType,
  joystickId: cuint
}

global sfml.SizeEvent: type <cimport 'sfSizeEvent', nodecl> = @record {
  type: sfml.EventType,
  width: cuint,
  height: cuint
}

global sfml.TouchEvent: type <cimport 'sfTouchEvent', nodecl> = @record {
  type: sfml.EventType,
  finger: cuint,
  x: cint,
  y: cint
}

global sfml.SensorEvent: type <cimport 'sfSensorEvent', nodecl> = @record {
  type: sfml.EventType,
  sensorType: sfml.SensorType,
  x: float32,
  y: float32,
  z: float32
}

global sfml.Event: type <cimport 'sfEvent',nodecl> = @union {
  type: sfml.EventType,
  size: sfml.SizeEvent,
  key: sfml.KeyEvent,
  text: sfml.TextEvent,
  mouseMove: sfml.MouseMoveEvent,
  mouseButton: sfml.MouseButtonEvent,
  mouseWheel: sfml.MouseWheelEvent,
  mouseWheelScroll: sfml.MouseWheelScrollEvent,
  joystickMove: sfml.JoystickMoveEvent,
  joystickButton: sfml.JoystickMoveEvent,
  joystickConnect: sfml.JoystickMoveEvent,
  touch: sfml.TouchEvent,
  sensor: sfml.SensorEvent,
}

global sfml.WindowStyle: type <cimport 'sfWindowStyle', nodecl, using> = @enum(cint) {
  None = 0,
  Titlebar = 1 << 0,
  Resize = 1 << 1,
  Close = 1 << 2,
  Fullscreen = 1 << 3
}

global sfml.DefaultStyle: cint <cimport 'sfDefaultStyle', nodecl, const>

global sfml.ContextAttribute: type <cimport 'sfContextAttribute', nodecl, using> = @enum(cint) {
  Default = 0,
  Core = 1 << 0,
  Debug = 1 << 2,
}

global sfml.ContextSettings: type <cimport 'sfContextSettings', nodecl> = @record {
  depthBits: cuint,
  stencilBits: cuint,
  antialiasingLevel: cuint,
  majorVersion: cuint,
  minorVersion: cuint,
  attributeFlags: sfml.Uint32,
  sRgbCapable: sfml.Bool,
}


-- Window
function sfml.Window.create(mode: sfml.VideoMode, title: cstring <const>, style: sfml.Uint32, settings: *sfml.ContextSettings <const>): *sfml.Window <cimport 'sfWindow_create', nodecl> end
function sfml.Window.create_unicode(mode: sfml.VideoMode, title: *[0]sfml.Uint32 <const>, style: sfml.Uint32, settings: *sfml.ContextSettings <const>): *sfml.Window <cimport 'sfWindow_createUnicode', nodecl> end
function sfml.Window.create_from_handle(handle: sfml.WindowHandle, settings: *sfml.ContextSettings <const>): *sfml.Window <cimport 'sfWindow_createFromHandle', nodecl> end
function sfml.Window.destroy(self: *sfml.Window): void <cimport 'sfWindow_destroy', nodecl> end
function sfml.Window.close(self: *sfml.Window): void <cimport 'sfWindow_close', nodecl> end
function sfml.Window.is_open(self: *sfml.Window <const>): sfml.Bool <cimport 'sfWindow_isOpen', nodecl> end
function sfml.Window.get_settings(self: *sfml.Window <const>): sfml.ContextSettings <cimport 'sfWindow_getSettings', nodecl> end
function sfml.Window.poll_event(self: *sfml.Window, event: *sfml.Event): sfml.Bool <cimport 'sfWindow_pollEvent', nodecl> end
function sfml.Window.wait_event(self: *sfml.Window, event: *sfml.Event): sfml.Bool <cimport 'sfWindow_waitEvent', nodecl> end
function sfml.Window.get_position(self: *sfml.Window <const>): sfml.Vector2i <cimport 'sfWindow_getPosition', nodecl> end
function sfml.Window.set_position(self: *sfml.Window, position: sfml.Vector2i): void <cimport 'sfWindow_setPosition', nodecl> end
function sfml.Window.get_size(self: *sfml.Window <const>): sfml.Vector2u <cimport 'sfWindow_getSize', nodecl> end
function sfml.Window.set_size(self: *sfml.Window, size: sfml.Vector2u): void <cimport 'sfWindow_setSize', nodecl> end
function sfml.Window.set_title(self: *sfml.Window, title: cstring <const>): void <cimport 'sfWindow_setTitle', nodecl> end
function sfml.Window.set_unicode_title(self: *sfml.Window, title: *[0]sfml.Uint32 <const>): void <cimport 'sfWindow_setUnicodeTitle', nodecl> end
function sfml.Window.set_icon(self: *sfml.Window, width: cuint, height: cuint, pixels: *[0]sfml.Uint8): void <cimport 'sfWindow_setIcon', nodecl> end
function sfml.Window.set_visible(self: *sfml.Window, visible: sfml.Bool): void <cimport 'sfWindow_setVisible', nodecl> end
function sfml.Window.set_vsync_enabled(self: *sfml.Window, enabled: sfml.Bool): void <cimport 'sfWindow_setVerticalSyncEnabled', nodecl> end
function sfml.Window.set_mouse_cursor_visible(self: *sfml.Window, visible: sfml.Bool): void <cimport 'sfWindow_setMouseCursorVisible', nodecl> end
function sfml.Window.set_mouse_cursor_grabbed(self: *sfml.Window, grabbed: sfml.Bool): void <cimport 'sfWindow_setMouseCursorGrabbed', nodecl> end
function sfml.Window.set_mouse_cursor(self: *sfml.Window, cursor: *sfml.Cursor <const>): void <cimport 'sfWindow_setMouseCursor', nodecl> end
function sfml.Window.set_key_repeat_enabled(self: *sfml.Window, enabled: sfml.Bool): void <cimport 'sfWindow_setKeyRepeatEnabled', nodecl> end
function sfml.Window.set_framerate_limit(self: *sfml.Window, threshold: float32): void <cimport 'sfWindow_setFramerateLimit', nodecl> end
function sfml.Window.set_active(self: *sfml.Window, active: sfml.Bool): void <cimport 'sfWindow_setActive', nodecl> end
function sfml.Window.request_focus(self: *sfml.Window): void <cimport 'sfWindow_requestFocus', nodecl> end
function sfml.Window.has_focus(self: *sfml.Window <const>): sfml.Bool <cimport 'sfWindow_hasFocus', nodecl> end
function sfml.Window.display(self: *sfml.Window): void <cimport 'sfWindow_display', nodecl> end
function sfml.Window.get_system_handle(self: *sfml.Window <const>): sfml.WindowHandle <cimport 'sfWindow_getSystemHandle', nodecl> end


-- Context
function sfml.Context.create(): *sfml.Context <cimport 'sfContext_create', nodecl> end
function sfml.Context.destroy(self: *sfml.Context): void <cimport 'sfContext_destroy', nodecl> end
function sfml.Context.set_active(self: *sfml.Context, active: sfml.Bool): sfml.Bool <cimport 'sfContext_setActive', nodecl> end
function sfml.Context.get_settings(self: *sfml.Context <const>): sfml.ContextSettings <cimport 'sfContext_getSettings', nodecl> end
function sfml.Context.get_active_context_id(): sfml.Uint64 <cimport 'sfContext_getActiveContextId', nodecl> end


-- Graphics
global sfml.CircleShape: type <cimport 'sfCircleShape', nodecl, forwarddecl> = @record {}
global sfml.ConvexShape: type <cimport 'sfConvexShape', nodecl, forwarddecl> = @record {}
global sfml.Font: type <cimport 'sfFont', nodecl, forwarddecl> = @record {}
global sfml.Image: type <cimport 'sfImage', nodecl, forwarddecl> = @record {}
global sfml.Shader: type <cimport 'sfShader', nodecl, forwarddecl> = @record {}
global sfml.RectangleShape: type <cimport 'sfRectangleShape', nodecl, forwarddecl> = @record {}
global sfml.RenderTexture: type <cimport 'sfRenderTexture', nodecl, forwarddecl> = @record {}
global sfml.RenderWindow: type <cimport 'sfRenderWindow', nodecl, forwarddecl> = @record {}
global sfml.Shape: type <cimport 'sfShape', nodecl, forwarddecl> = @record {}
global sfml.Sprite: type <cimport 'sfSprite', nodecl, forwarddecl> = @record {}
global sfml.Text: type <cimport 'sfText', nodecl, forwarddecl> = @record {}
global sfml.Texture: type <cimport 'sfTexture', nodecl, forwarddecl> = @record {}
global sfml.Transformable: type <cimport 'sfTransformable', nodecl, forwarddecl> = @record {}
global sfml.VertexArray: type <cimport 'sfVertexArray', nodecl, forwarddecl> = @record {}
global sfml.VertexBuffer: type <cimport 'sfVertexBuffer', nodecl, forwarddecl> = @record {}
global sfml.View: type <cimport 'sfView', nodecl, forwarddecl> = @record {}


global sfml.BlendFactor: type <cimport 'sfBlendFactor', nodecl, using> = @enum(cint) {
  Zero = 0,
  One,
  SrcColor,
  OneMinusSrcColor,
  DstColor,
  OneMinusDstColor,
  SrcAlpha,
  OneMinusSrcAlpha,
  DstAlpha,
  OneMinusDstAlpha
}

global sfml.BlendEquation: type <cimport 'sfBlendEquation', nodecl, using> = @enum(cint) {
  Add = 0,
  Subtract,
  ReverseSubtract
}

global sfml.BlendMode: type <cimport 'sfBlendMode', nodecl> = @record {
  colorSrcFactor: sfml.BlendFactor,
  colorDstFactor: sfml.BlendFactor,
  colorEquation: sfml.BlendEquation,
  alphaSrcFactor: sfml.BlendFactor,
  alphaDstFactor: sfml.BlendFactor,
  alphaEquation: sfml.BlendEquation
}

global sfml.BlendAlpha: sfml.BlendMode <cimport 'sfBlendAlpha', nodecl, const>
global sfml.BlendAdd: sfml.BlendMode <cimport 'sfBlendAdd', nodecl, const>
global sfml.BlendMultiply: sfml.BlendMode <cimport 'sfBlendMultiply', nodecl, const>
global sfml.BlendNone: sfml.BlendMode <cimport 'sfBlendNone', nodecl, const>

global sfml.FloatRect: type <cimport 'sfFloatRect', nodecl> = @record {
  left: float32,
  top: float32,
  width: float32,
  height: float32
}

global sfml.IntRect: type <cimport 'sfIntRect', nodecl> = @record {
  left: cint,
  top: cint,
  width: cint,
  height: cint
}


function sfml.FloatRect.contains(self: *sfml.FloatRect <const>, x: float32, y: float32): sfml.Bool <cimport 'sfFloatRect_contains', nodecl> end
function sfml.IntRect.contains(self: *sfml.IntRect <const>, x: cint, y: cint): sfml.Bool <cimport 'sfIntRect_contains', nodecl> end
function sfml.FloatRect.intersects(self: *sfml.FloatRect <const>, rect2: *sfml.FloatRect <const>, intersection: *sfml.FloatRect): sfml.Bool <cimport 'sfFloatRect_intersects', nodecl> end
function sfml.IntRect.intersects(self: *sfml.IntRect <const>, rect2: *sfml.IntRect <const>, intersection: *sfml.IntRect): sfml.Bool <cimport 'sfIntRect_intersects', nodecl> end


global sfml.Color: type <cimport 'sfColor', nodecl> = @record {
  r: sfml.Uint8,
  g: sfml.Uint8,
  b: sfml.Uint8,
  a: sfml.Uint8
}

global sfml.Transform: type <cimport 'sfTransform', nodecl> = @record {
  matrix: [9]float32
}

global sfml.Glyph: type <cimport 'sfGlyph', nodecl> = @record {
  advance: float32,
  bounds: sfml.FloatRect,
  textureRect: sfml.IntRect
}

global sfml.Vertex: type <cimport 'sfVertex', nodecl> = @record {
  position: sfml.Vector2f,
  color: sfml.Color,
  texCoords: sfml.Vector2f
}

global sfml.PrimitiveType: type <cimport 'sfPrimitiveType', nodecl, using> = @enum(cint) {
  Points = 0,
  Lines,
  LineStrip,
  Triangles,
  TriangleStrip,
  TriangleFan,
  Quads
}

global sfml.LinesStrip: cint <cimport 'sfLinesStrip', nodecl, const>
global sfml.TrianglesStrip: cint <cimport 'sfTrianglesStrip', nodecl, const>
global sfml.TrianglesFan: cint <cimport 'sfTrianglesFan', nodecl, const>

global sfml.RenderStates: type <cimport 'sfRenderStates', nodecl> = @record {
  blendMode: sfml.BlendMode,
  transform: sfml.Transform,
  texture: *sfml.Texture,
  shader: *sfml.Shader
}

global sfml.FontInfo: type <cimport 'sfFontInfo', nodecl> = @record {
  family: cstring
}


-- Color: Constants
global sfml.Black: sfml.Color <cimport 'sfBlack', nodecl, const>
global sfml.White: sfml.Color <cimport 'sfWhite', nodecl, const>
global sfml.Red: sfml.Color <cimport 'sfRed', nodecl, const>
global sfml.Green: sfml.Color <cimport 'sfGreen', nodecl, const>
global sfml.Blue: sfml.Color <cimport 'sfBlue', nodecl, const>
global sfml.Yellow: sfml.Color <cimport 'sfYellow', nodecl, const>
global sfml.Magenta: sfml.Color <cimport 'sfMagenta', nodecl, const>
global sfml.Cyan: sfml.Color <cimport 'sfCyan', nodecl, const>
global sfml.Transparent: sfml.Color <cimport 'sfTransparent', nodecl, const>


-- Color
function sfml.Color.from_rgb(red: sfml.Uint8, green: sfml.Uint8, blue: sfml.Uint8): sfml.Color <cimport 'sfColor_fromRGB', nodecl> end
function sfml.Color.from_rgba(red: sfml.Uint8, green: sfml.Uint8, blue: sfml.Uint8, alpha: sfml.Uint8): sfml.Color <cimport 'sfColor_fromRGBA', nodecl> end
function sfml.Color.from_integer(color: sfml.Uint32): sfml.Color <cimport 'sfColor_fromInteger', nodecl> end

function sfml.Color.to_integer(color: sfml.Color): sfml.Uint32 <cimport 'sfColor_toInteger', nodecl> end
function sfml.Color.add(color1: sfml.Color, color2: sfml.Color): sfml.Color <cimport 'sfColor_add', nodecl> end
function sfml.Color.subtract(color1: sfml.Color, color2: sfml.Color): sfml.Color <cimport 'sfColor_subtract', nodecl> end
function sfml.Color.modulate(color1: sfml.Color, color2: sfml.Color): sfml.Color <cimport 'sfColor_modulate', nodecl> end


-- Vertex Array
function sfml.VertexArray.create(): *sfml.VertexArray <cimport 'sfVertexArray_create', nodecl> end

function sfml.VertexArray.copy(self: *sfml.VertexArray <const>): *sfml.VertexArray <cimport 'sfVertexArray_copy', nodecl> end
function sfml.VertexArray.destroy(self: *sfml.VertexArray): void <cimport 'sfVertexArray_destroy', nodecl> end
function sfml.VertexArray.get_vertex_count(self: *sfml.VertexArray <const>): csize <cimport 'sfVertexArray_getVertexCount', nodecl> end
function sfml.VertexArray.get_vertex(self: *sfml.VertexArray, index: csize): *sfml.Vertex <cimport 'sfVertexArray_getVertex', nodecl> end
function sfml.VertexArray.clear(self: *sfml.VertexArray): void <cimport 'sfVertexArray_clear', nodecl> end
function sfml.VertexArray.resize(self: *sfml.VertexArray, vertexCount: csize): void <cimport 'sfVertexArray_resize', nodecl> end
function sfml.VertexArray.append(self: *sfml.VertexArray, vertex: sfml.Vertex): void <cimport 'sfVertexArray_append', nodecl> end
function sfml.VertexArray.get_primitive_type(self: *sfml.VertexArray): sfml.PrimitiveType <cimport 'sfVertexArray_getPrimitiveType', nodecl> end
function sfml.VertexArray.set_primitive_type(self: *sfml.VertexArray, type: sfml.PrimitiveType): void <cimport 'sfVertexArray_setPrimitiveType', nodecl> end
function sfml.VertexArray.get_bounds(self: *sfml.VertexArray): sfml.FloatRect <cimport 'sfVertexArray_getBounds', nodecl> end


-- Transformable
function sfml.Transformable.create(): *sfml.Transformable <cimport 'sfTransformable_create', nodecl> end

function sfml.Transformable.copy(self: *sfml.Transformable <const>): *sfml.Transformable <cimport 'sfTransformable_copy', nodecl> end
function sfml.Transformable.destroy(self: *sfml.Transformable): void <cimport 'sfTransformable_destroy', nodecl> end
function sfml.Transformable.get_position(self: *sfml.Transformable <const>): sfml.Vector2f <cimport 'sfTransformable_getPosition', nodecl> end
function sfml.Transformable.set_position(self: *sfml.Transformable, position: sfml.Vector2f): void <cimport 'sfTransformable_setPosition', nodecl> end
function sfml.Transformable.get_rotation(self: *sfml.Transformable <const>): float32 <cimport 'sfTransformable_getRotation', nodecl> end
function sfml.Transformable.set_rotation(self: *sfml.Transformable, angle: float32): void <cimport 'sfTransformable_setRotation', nodecl> end
function sfml.Transformable.get_scale(self: *sfml.Transformable <const>): sfml.Vector2f <cimport 'sfTransformable_getScale', nodecl> end
function sfml.Transformable.set_scale(self: *sfml.Transformable, scale: sfml.Vector2f): void <cimport 'sfTransformable_setScale', nodecl> end
function sfml.Transformable.get_origin(self: *sfml.Transformable <const>): sfml.Vector2f <cimport 'sfTransformable_getOrigin', nodecl> end
function sfml.Transformable.set_origin(self: *sfml.Transformable, origin: sfml.Vector2f): void <cimport 'sfTransformable_setOrigin', nodecl> end
function sfml.Transformable.move(self: *sfml.Transformable, offset: sfml.Vector2f): void <cimport 'sfTransformable_move', nodecl> end
function sfml.Transformable.rotate(self: *sfml.Transformable, angle: float32): void <cimport 'sfTransformable_rotate', nodecl> end
function sfml.Transformable.scale(self: *sfml.Transformable, factors: sfml.Vector2f): void <cimport 'sfTransformable_scale', nodecl> end
function sfml.Transformable.get_transform(self: *sfml.Transformable <const>): sfml.Transform <cimport 'sfTransformable_getTransform', nodecl> end
function sfml.Transformable.get_inverse_transform(self: *sfml.Transformable <const>): sfml.Transform <cimport 'sfTransformable_getInverseTransform', nodecl> end


-- Transform
global sfml.Transform_Identity: sfml.Transform <cimport 'sfTransform_Identity', nodecl, const>
function sfml.Transform.from_matrix(a00: float32, a01: float32, a02: float32, a10: float32, a11: float32, a12: float32, a20: float32, a21: float32, a22: float32): sfml.Transform <cimport 'sfTransform_fromMatrix', nodecl> end
function sfml.Transform.get_matrix(self: *sfml.Transform <const>, matrix: *[0]float32): void <cimport 'sfTransform_getMatrix', nodecl> end
function sfml.Transform.get_inverse(self: *sfml.Transform <const>): sfml.Transform <cimport 'sfTransform_getInverse', nodecl> end
function sfml.Transform.transform_point(self: *sfml.Transform <const>, point: sfml.Vector2f): sfml.Vector2f <cimport 'sfTransform_transformPoint', nodecl> end
function sfml.Transform.transform_rect(self: *sfml.Transform <const>, rectangle: sfml.FloatRect): sfml.FloatRect <cimport 'sfTransform_transformRect', nodecl> end
function sfml.Transform.combine(self: *sfml.Transform, other: *sfml.Transform <const>): sfml.FloatRect <cimport 'sfTransform_combine', nodecl> end
function sfml.Transform.translate(self: *sfml.Transform, x: float32, y: float32): void <cimport 'sfTransform_translate', nodecl> end
function sfml.Transform.rotate(self: *sfml.Transform, angle: float32): void <cimport 'sfTransform_rotate', nodecl> end
function sfml.Transform.rotate_with_center(self: *sfml.Transform, angle: float32, centerX: float32, centerY: float32): void <cimport 'sfTransform_rotateWithCenter', nodecl> end
function sfml.Transform.scale(self: *sfml.Transform, scaleX: float32, scaleY: float32): void <cimport 'sfTransform_scale', nodecl> end
function sfml.Transform.scale_with_center(self: *sfml.Transform, scaleX: float32, scaleY: float32, centerX: float32, centerY: float32): void <cimport 'sfTransform_scaleWithCenter', nodecl> end
function sfml.Transform.equal(self: *sfml.Transform, right: *sfml.Transform): sfml.Bool <cimport 'sfTransform_equal', nodecl> end


-- OpenGL
global sfml.GlslVec2: type <cimport 'sfGlslVec2', nodecl> = @sfml.Vector2f
global sfml.GlslIvec2: type <cimport 'sfGlslIvec2', nodecl> = @sfml.Vector2i

global sfml.GlslBvec2: type <cimport 'sfGlslBvec2', nodecl> = @record {
  x: sfml.Bool,
  y: sfml.Bool
}

global sfml.GlslVec3: type <cimport 'sfGlslVec3', nodecl> = @sfml.Vector3f

global sfml.GlslIvec3: type <cimport 'sfGlslIvec3', nodecl> = @record {
  x: cint,
  y: cint,
  z: cint
}

global sfml.GlslBvec3: type <cimport 'sfGlslBvec3', nodecl> = @record {
  x: sfml.Bool,
  y: sfml.Bool,
  z: sfml.Bool
}

global sfml.GlslVec4: type <cimport 'sfGlslVec4', nodecl> = @record {
  x: float32,
  y: float32,
  z: float32,
  w: float32
}

global sfml.GlslIvec4: type <cimport 'sfGlslIvec4', nodecl> = @record {
  x: cint,
  y: cint,
  z: cint,
  w: cint
}

global sfml.GlslBvec4: type <cimport 'sfGlslBvec4', nodecl> = @record {
  x: sfml.Bool,
  y: sfml.Bool,
  z: sfml.Bool,
  w: sfml.Bool
}

global sfml.GlslMat3: type <cimport 'sfGlslMat3', nodecl> = @record {
  array: [9]float32
}

global sfml.GlslMat4: type <cimport 'sfGlslMat4', nodecl> = @record {
  array: [16]float32
}


-- View
function sfml.View.create(): *sfml.View <cimport 'sfView_create', nodecl> end
function sfml.View.create_from_rect(rectangle: sfml.FloatRect): *sfml.View <cimport 'sfView_createFromRect', nodecl> end

function sfml.View.copy(self: *sfml.View <const>): *sfml.View <cimport 'sfView_copy', nodecl> end
function sfml.View.destroy(self: *sfml.View): void <cimport 'sfView_destroy', nodecl> end
function sfml.View.get_center(self: *sfml.View <const>): sfml.Vector2f <cimport 'sfView_getCenter', nodecl> end
function sfml.View.set_center(self: *sfml.View, center: sfml.Vector2f): void <cimport 'sfView_setCenter', nodecl> end
function sfml.View.get_size(self: *sfml.View <const>): sfml.Vector2f <cimport 'sfView_getSize', nodecl> end
function sfml.View.set_size(self: *sfml.View, size: sfml.Vector2f): void <cimport 'sfView_setSize', nodecl> end
function sfml.View.get_rotation(self: *sfml.View <const>): float32 <cimport 'sfView_getRotation', nodecl> end
function sfml.View.set_rotation(self: *sfml.View, angle: float32): void <cimport 'sfView_setRotation', nodecl> end
function sfml.View.get_viewport(self: *sfml.View <const>): sfml.FloatRect <cimport 'sfView_getViewport', nodecl> end
function sfml.View.set_viewport(self: *sfml.View, viewport: sfml.FloatRect): void <cimport 'sfView_setViewport', nodecl> end
function sfml.View.reset(self: *sfml.View, rectangle: sfml.FloatRect): void <cimport 'sfView_reset', nodecl> end
function sfml.View.move(self: *sfml.View, offset: sfml.Vector2f): void <cimport 'sfView_move', nodecl> end
function sfml.View.rotate(self: *sfml.View, angle: float32): void <cimport 'sfView_rotate', nodecl> end
function sfml.View.zoom(self: *sfml.View, factor: float32): void <cimport 'sfView_zoom', nodecl> end


-- Font
function sfml.Font.create_from_file(filename: cstring <const>): *sfml.Font <cimport 'sfFont_createFromFile', nodecl> end
function sfml.Font.create_from_memory(data: pointer <const>, sizeInBytes: csize): *sfml.Font <cimport 'sfFont_createFromMemory', nodecl> end
function sfml.Font.create_from_stream(stream: *sfml.InputStream): *sfml.Font <cimport 'sfFont_createFromStream', nodecl> end

function sfml.Font.copy(self: *sfml.Font <const>): *sfml.Font <cimport 'sfFont_copy', nodecl> end
function sfml.Font.destroy(self: *sfml.Font): void <cimport 'sfFont_destroy', nodecl> end
function sfml.Font.get_glyph(self: *sfml.Font <const>, codePoint: sfml.Uint32, characterSize: cuint, bold: sfml.Bool, outlineThickness: float32): sfml.Glyph <cimport 'sfFont_getGlyph', nodecl> end
function sfml.Font.get_kerning(self: *sfml.Font <const>, first: sfml.Uint32, second: sfml.Uint32, characterSize: cuint): float32 <cimport 'sfFont_getKerning', nodecl> end
function sfml.Font.get_line_spacing(self: *sfml.Font <const>, characterSize: cuint): float32 <cimport 'sfFont_getLineSpacing', nodecl> end
function sfml.Font.get_underline_position(self: *sfml.Font <const>, characterSize: cuint): float32 <cimport 'sfFont_getUnderlinePosition', nodecl> end
function sfml.Font.get_underline_thickness(self: *sfml.Font <const>, characterSize: cuint): float32 <cimport 'sfFont_getUnderlineThickness', nodecl> end
function sfml.Font.get_texture(self: *sfml.Font <const>, characterSize: cuint): *sfml.Texture <cimport 'sfFont_getTexture', nodecl> end
function sfml.Font.get_info(self: *sfml.Font <const>): sfml.FontInfo <cimport 'sfFont_getInfo', nodecl> end


-- Image
function sfml.Image.create(width: cuint, height: cuint): *sfml.Image <cimport 'sfImage_create', nodecl> end
function sfml.Image.create_from_color(width: cuint, height: cuint, color: sfml.Color): *sfml.Image <cimport 'sfImage_createFromColor', nodecl> end
function sfml.Image.create_from_pixels(width: cuint, height: cuint, pixels: *[0]sfml.Uint8): *sfml.Image <cimport 'sfImage_createFromPixels', nodecl> end
function sfml.Image.create_from_file(filename: cstring <const>): *sfml.Image <cimport 'sfImage_createFromFile', nodecl> end
function sfml.Image.create_from_memory(data: pointer <const>, size: csize): *sfml.Image <cimport 'sfImage_createFromMemory', nodecl> end
function sfml.Image.create_from_stream(stream: *sfml.InputStream): *sfml.Image <cimport 'sfImage_createFromStream', nodecl> end

function sfml.Image.copy(self: *sfml.Image <const>): *sfml.Image <cimport 'sfImage_copy', nodecl> end
function sfml.Image.destroy(self: *sfml.Image): void <cimport 'sfImage_destroy', nodecl> end
function sfml.Image.save_to_file(self: *sfml.Image <const>, filename: cstring <const>): sfml.Bool <cimport 'sfImage_saveToFile', nodecl> end
function sfml.Image.get_size(self: *sfml.Image <const>): sfml.Vector2u <cimport 'sfImage_getSize', nodecl> end
function sfml.Image.create_mask_from_color(self: *sfml.Image, color: sfml.Color, alpha: sfml.Uint8): void <cimport 'sfImage_createMaskFromFile', nodecl> end
function sfml.Image.copy_image(self: *sfml.Image, source: *sfml.Image <const>, destX: cuint, destY: cuint, sourceRect: sfml.IntRect, applyAlpha: sfml.Bool): void <cimport 'sfImage_copyImage', nodecl> end
function sfml.Image.get_pixel(self: *sfml.Image <const>, x: cuint, y: cuint): sfml.Color <cimport 'sfImage_getPixel', nodecl> end
function sfml.Image.set_pixel(self: *sfml.Image, x: cuint, y: cuint, color: sfml.Color): void <cimport 'sfImage_setPixel', nodecl> end
function sfml.Image.get_pixels_ptr(self: *sfml.Image <const>): *[0]sfml.Uint8 <cimport 'sfImage_getPixelsPtr', nodecl> end
function sfml.Image.flip_horizontally(self: *sfml.Image): void <cimport 'sfImage_flipHorizontally', nodecl> end
function sfml.Image.flip_vertically(self: *sfml.Image): void <cimport 'sfImage_flipVertically', nodecl> end


-- Shape: Circle
function sfml.CircleShape.create(): *sfml.CircleShape <cimport 'sfCircleShape_create', nodecl> end

function sfml.CircleShape.copy(self: *sfml.CircleShape <const>): *sfml.CircleShape <cimport 'sfCircleShape_copy', nodecl> end
function sfml.CircleShape.destroy(self: *sfml.CircleShape): void <cimport 'sfCircleShape_destroy', nodecl> end
function sfml.CircleShape.get_position(self: *sfml.CircleShape <const>): sfml.Vector2f <cimport 'sfCircleShape_getPosition', nodecl> end
function sfml.CircleShape.set_position(self: *sfml.CircleShape, position: sfml.Vector2f): void <cimport 'sfCircleShape_setPosition', nodecl> end
function sfml.CircleShape.get_rotation(self: *sfml.CircleShape <const>): float32 <cimport 'sfCircleShape_getRotation', nodecl> end
function sfml.CircleShape.set_rotation(self: *sfml.CircleShape, angle: float32): void <cimport 'sfCircleShape_setRotation', nodecl> end
function sfml.CircleShape.get_scale(self: *sfml.CircleShape <const>): sfml.Vector2f <cimport 'sfCircleShape_getScale', nodecl> end
function sfml.CircleShape.set_scale(self: *sfml.CircleShape, scale: sfml.Vector2f): void <cimport 'sfCircleShape_setScale', nodecl> end
function sfml.CircleShape.get_origin(self: *sfml.CircleShape <const>): sfml.Vector2f <cimport 'sfCircleShape_getOrigin', nodecl> end
function sfml.CircleShape.set_origin(self: *sfml.CircleShape, origin: sfml.Vector2f): void <cimport 'sfCircleShape_setOrigin', nodecl> end
function sfml.CircleShape.get_transform(self: *sfml.CircleShape <const>): sfml.Transform <cimport 'sfCircleShape_getTransform', nodecl> end
function sfml.CircleShape.get_inverse_transform(self: *sfml.CircleShape <const>): sfml.Transform <cimport 'sfCircleShape_getInverseTransform', nodecl> end
function sfml.CircleShape.get_texture(self: *sfml.CircleShape <const>): *sfml.Texture <cimport 'sfCircleShape_getTexture', nodecl> end
function sfml.CircleShape.set_texture(self: *sfml.CircleShape, texture: *sfml.Texture <const>, resetRect: sfml.Bool): void <cimport 'sfCircleShape_setTexture', nodecl> end
function sfml.CircleShape.get_texture_rect(self: *sfml.CircleShape <const>): sfml.IntRect <cimport 'sfCircleShape_getTextureRect', nodecl> end
function sfml.CircleShape.set_texture_rect(self: *sfml.CircleShape, rect: sfml.IntRect): void <cimport 'sfCircleShape_setTextureRect', nodecl> end
function sfml.CircleShape.get_fill_color(self: *sfml.CircleShape <const>): sfml.Color <cimport 'sfCircleShape_getFillColor', nodecl> end
function sfml.CircleShape.set_fill_color(self: *sfml.CircleShape, color: sfml.Color): void <cimport 'sfCircleShape_setFillColor', nodecl> end
function sfml.CircleShape.get_radius(self: *sfml.CircleShape <const>): float32 <cimport 'sfCircleShape_getRadius', nodecl> end
function sfml.CircleShape.set_radius(self: *sfml.CircleShape, radius: float32): void <cimport 'sfCircleShape_setRadius', nodecl> end
function sfml.CircleShape.move(self: *sfml.CircleShape, offset: sfml.Vector2f): void <cimport 'sfCircleShape_move', nodecl> end
function sfml.CircleShape.rotate(self: *sfml.CircleShape, angle: float32): void <cimport 'sfCircleShape_rotate', nodecl> end
function sfml.CircleShape.scale(self: *sfml.CircleShape, factors: sfml.Vector2f): void <cimport 'sfCircleShape_scale', nodecl> end 
function sfml.CircleShape.set_outline_color(self: *sfml.CircleShape, color: sfml.Color): void <cimport 'sfCircleShape_setOutlineColor', nodecl> end
function sfml.CircleShape.set_outline_thickness(self: *sfml.CircleShape, thickness: float32): void <cimport 'sfCircleShape_setOutlineThickness', nodecl> end
function sfml.CircleShape.get_outline_color(self: *sfml.CircleShape <const>): sfml.Color <cimport 'sfCircleShape_getOutlineColor', nodecl> end
function sfml.CircleShape.get_outline_thickness(self: *sfml.CircleShape <const>): float32 <cimport 'sfCircleShape_getOutlineThickness', nodecl> end
function sfml.CircleShape.get_point_count(self: *sfml.CircleShape <const>): csize <cimport 'sfCircleShape_getPointCount', nodecl> end
function sfml.CircleShape.get_point(self: *sfml.CircleShape <const>, index: csize): sfml.Vector2f <cimport 'sfCircleShape_getPoint', nodecl> end
function sfml.CircleShape.set_point_count(self: *sfml.CircleShape, count: csize): void <cimport 'sfCircleShape_setPointCount', nodecl> end
function sfml.CircleShape.get_local_bounds(self: *sfml.CircleShape <const>): sfml.FloatRect <cimport 'sfCircleShape_getLocalBounds', nodecl> end
function sfml.CircleShape.get_global_bounds(self: *sfml.CircleShape <const>): sfml.FloatRect <cimport 'sfCircleShape_getGlobalBounds', nodecl> end


-- Shape: Convex
function sfml.ConvexShape.create(): *sfml.ConvexShape <cimport 'sfConvexShape_create', nodecl> end

function sfml.ConvexShape.copy(self: *sfml.ConvexShape <const>): *sfml.ConvexShape <cimport 'sfConvexShape_copy', nodecl> end
function sfml.ConvexShape.destroy(self: *sfml.ConvexShape): void <cimport 'sfConvexShape_destroy', nodecl> end
function sfml.ConvexShape.get_position(self: *sfml.ConvexShape <const>): sfml.Vector2f <cimport 'sfConvexShape_getPosition', nodecl> end
function sfml.ConvexShape.set_position(self: *sfml.ConvexShape, position: sfml.Vector2f): void <cimport 'sfConvexShape_setPosition', nodecl> end
function sfml.ConvexShape.get_rotation(self: *sfml.ConvexShape <const>): float32 <cimport 'sfConvexShape_getRotation', nodecl> end
function sfml.ConvexShape.set_rotation(self: *sfml.ConvexShape, angle: float32): void <cimport 'sfConvexShape_setRotation', nodecl> end
function sfml.ConvexShape.get_scale(self: *sfml.ConvexShape <const>): sfml.Vector2f <cimport 'sfConvexShape_getScale', nodecl> end
function sfml.ConvexShape.set_scale(self: *sfml.ConvexShape, scale: sfml.Vector2f): void <cimport 'sfConvexShape_setScale', nodecl> end
function sfml.ConvexShape.get_origin(self: *sfml.ConvexShape <const>): sfml.Vector2f <cimport 'sfConvexShape_getOrigin', nodecl> end
function sfml.ConvexShape.set_origin(self: *sfml.ConvexShape, origin: sfml.Vector2f): void <cimport 'sfConvexShape_setOrigin', nodecl> end
function sfml.ConvexShape.get_texture(self: *sfml.ConvexShape <const>): *sfml.Texture <cimport 'sfConvexShape_getTexture', nodecl> end
function sfml.ConvexShape.set_texture(self: *sfml.ConvexShape, texture: *sfml.Texture <const>, resetRect: sfml.Bool): void <cimport 'sfConvexShape_setTexture', nodecl> end
function sfml.ConvexShape.get_fill_color(self: *sfml.ConvexShape <const>): sfml.Color <cimport 'sfConvexShape_getFillColor', nodecl> end
function sfml.ConvexShape.set_fill_color(self: *sfml.ConvexShape, color: sfml.Color): void <cimport 'sfConvexShape_setFillColor', nodecl> end
function sfml.ConvexShape.get_outline_color(self: *sfml.ConvexShape <const>): sfml.Color <cimport 'sfConvexShape_getOutlineColor', nodecl> end
function sfml.ConvexShape.set_outline_color(self: *sfml.ConvexShape, color: sfml.Color): void <cimport 'sfConvexShape_setOutlineColor', nodecl> end
function sfml.ConvexShape.get_outline_thickness(self: *sfml.ConvexShape <const>): float32 <cimport 'sfConvexShape_getOutlineThickness', nodecl> end
function sfml.ConvexShape.set_outline_thickness(self: *sfml.ConvexShape, thickness: float32): void <cimport 'sfConvexShape_setOutlineThickness', nodecl> end
function sfml.ConvexShape.get_texture_rect(self: *sfml.ConvexShape <const>): sfml.IntRect <cimport 'sfConvexShape_getTextureRect', nodecl> end
function sfml.ConvexShape.set_texture_rect(self: *sfml.ConvexShape, rect: sfml.IntRect): void <cimport 'sfConvexShape_setTextureRect', nodecl> end
function sfml.ConvexShape.get_radius(self: *sfml.ConvexShape <const>): float32 <cimport 'sfConvexShape_getRadius', nodecl> end
function sfml.ConvexShape.set_radius(self: *sfml.ConvexShape, radius: float32): void <cimport 'sfConvexShape_setRadius', nodecl> end
function sfml.ConvexShape.get_point_count(self: *sfml.ConvexShape <const>): csize <cimport 'sfConvexShape_getPointCount', nodecl> end
function sfml.ConvexShape.set_point_count(self: *sfml.ConvexShape, count: csize): void <cimport 'sfConvexShape_setPointCount', nodecl> end
function sfml.ConvexShape.get_transform(self: *sfml.ConvexShape <const>): sfml.Transform <cimport 'sfConvexShape_getTransform', nodecl> end
function sfml.ConvexShape.get_inverse_transform(self: *sfml.ConvexShape <const>): sfml.Transform <cimport 'sfConvexShape_getInverseTransform', nodecl> end
function sfml.ConvexShape.move(self: *sfml.ConvexShape, offset: sfml.Vector2f): void <cimport 'sfConvexShape_move', nodecl> end
function sfml.ConvexShape.rotate(self: *sfml.ConvexShape, angle: float32): void <cimport 'sfConvexShape_rotate', nodecl> end
function sfml.ConvexShape.scale(self: *sfml.ConvexShape, factors: sfml.Vector2f): void <cimport 'sfConvexShape_scale', nodecl> end
function sfml.ConvexShape.get_point(self: *sfml.ConvexShape <const>, index: csize): sfml.Vector2f <cimport 'sfConvexShape_getPoint', nodecl> end
function sfml.ConvexShape.get_local_bounds(self: *sfml.ConvexShape <const>): sfml.FloatRect <cimport 'sfConvexShape_getLocalBounds', nodecl> end
function sfml.ConvexShape.get_global_bounds(self: *sfml.ConvexShape <const>): sfml.FloatRect <cimport 'sfConvexShape_getGlobalBounds', nodecl> end


-- Rectangle
function sfml.RectangleShape.create(): *sfml.RectangleShape <cimport 'sfRectangleShape_create', nodecl> end

function sfml.RectangleShape.copy(self: *sfml.RectangleShape <const>): *sfml.RectangleShape <cimport 'sfRectangleShape_copy', nodecl> end
function sfml.RectangleShape.destroy(self: *sfml.RectangleShape): void <cimport 'sfRectangleShape_destroy', nodecl> end
function sfml.RectangleShape.get_position(self: *sfml.RectangleShape <const>): sfml.Vector2f <cimport 'sfRectangleShape_getPosition', nodecl> end
function sfml.RectangleShape.set_position(self: *sfml.RectangleShape, position: sfml.Vector2f): void <cimport 'sfRectangleShape_setPosition', nodecl> end
function sfml.RectangleShape.get_rotation(self: *sfml.RectangleShape <const>): float32 <cimport 'sfRectangleShape_getRotation', nodecl> end
function sfml.RectangleShape.set_rotation(self: *sfml.RectangleShape, angle: float32): void <cimport 'sfRectangleShape_setRotation', nodecl> end
function sfml.RectangleShape.get_scale(self: *sfml.RectangleShape <const>): sfml.Vector2f <cimport 'sfRectangleShape_getScale', nodecl> end
function sfml.RectangleShape.set_scale(self: *sfml.RectangleShape, scale: sfml.Vector2f): void <cimport 'sfRectangleShape_setScale', nodecl> end
function sfml.RectangleShape.get_origin(self: *sfml.RectangleShape <const>): sfml.Vector2f <cimport 'sfRectangleShape_getOrigin', nodecl> end
function sfml.RectangleShape.set_origin(self: *sfml.RectangleShape, origin: sfml.Vector2f): void <cimport 'sfRectangleShape_setOrigin', nodecl> end
function sfml.RectangleShape.get_texture(self: *sfml.RectangleShape <const>): *sfml.Texture <cimport 'sfRectangleShape_getTexture', nodecl> end
function sfml.RectangleShape.set_texture(self: *sfml.RectangleShape, texture: *sfml.Texture <const>, resetRect: sfml.Bool): void <cimport 'sfRectangleShape_setTexture', nodecl> end
function sfml.RectangleShape.get_texture_rect(self: *sfml.RectangleShape <const>): sfml.IntRect <cimport 'sfRectangleShape_getTextureRect', nodecl> end
function sfml.RectangleShape.set_texture_rect(self: *sfml.RectangleShape, rect: sfml.IntRect): void <cimport 'sfRectangleShape_setTextureRect', nodecl> end
function sfml.RectangleShape.get_fill_color(self: *sfml.RectangleShape <const>): sfml.Color <cimport 'sfRectangleShape_getFillColor', nodecl> end
function sfml.RectangleShape.set_fill_color(self: *sfml.RectangleShape, color: sfml.Color): void <cimport 'sfRectangleShape_setFillColor', nodecl> end
function sfml.RectangleShape.get_outline_color(self: *sfml.RectangleShape <const>): sfml.Color <cimport 'sfRectangleShape_getOutlineColor', nodecl> end
function sfml.RectangleShape.set_outline_color(self: *sfml.RectangleShape, color: sfml.Color): void <cimport 'sfRectangleShape_setOutlineColor', nodecl> end
function sfml.RectangleShape.get_outline_thickness(self: *sfml.RectangleShape <const>): float32 <cimport 'sfRectangleShape_getOutlineThickness', nodecl> end
function sfml.RectangleShape.set_outline_thickness(self: *sfml.RectangleShape, thickness: float32): void <cimport 'sfRectangleShape_setOutlineThickness', nodecl> end
function sfml.RectangleShape.get_size(self: *sfml.RectangleShape <const>): sfml.Vector2f <cimport 'sfRectangleShape_getSize', nodecl> end
function sfml.RectangleShape.set_size(self: *sfml.RectangleShape, size: float32): void <cimport 'sfRectangleShape_setSize', nodecl> end
function sfml.RectangleShape.get_point_count(self: *sfml.RectangleShape <const>): csize <cimport 'sfRectangleShape_getPointCount', nodecl> end
function sfml.RectangleShape.set_point_count(self: *sfml.RectangleShape, count: csize): void <cimport 'sfRectangleShape_setPointCount', nodecl> end
function sfml.RectangleShape.move(self: *sfml.RectangleShape, offset: sfml.Vector2f): void <cimport 'sfRectangleShape_move', nodecl> end
function sfml.RectangleShape.rotate(self: *sfml.RectangleShape, angle: float32): void <cimport 'sfRectangleShape_rotate', nodecl> end
function sfml.RectangleShape.scale(self: *sfml.RectangleShape, factors: sfml.Vector2f): void <cimport 'sfRectangleShape_scale', nodecl> end
function sfml.RectangleShape.get_transform(self: *sfml.RectangleShape <const>): sfml.Transform <cimport 'sfRectangleShape_getTransform', nodecl> end
function sfml.RectangleShape.get_inverse_transform(self: *sfml.RectangleShape <const>): sfml.Transform <cimport 'sfRectangleShape_getInverseTransform', nodecl> end
function sfml.RectangleShape.get_point(self: *sfml.RectangleShape <const>, index: csize): sfml.Vector2f <cimport 'sfRectangleShape_getPoint', nodecl> end
function sfml.RectangleShape.get_local_bounds(self: *sfml.RectangleShape <const>): sfml.FloatRect <cimport 'sfRectangleShape_getLocalBounds', nodecl> end
function sfml.RectangleShape.get_global_bounds(self: *sfml.RectangleShape <const>): sfml.FloatRect <cimport 'sfRectangleShape_getGlobalBounds', nodecl> end


-- Render Texture
function sfml.RenderTexture.create(width: cuint, height: cuint, depthBuffer: sfml.Bool): *sfml.RenderTexture <cimport 'sfRenderTexture_create', nodecl> end
function sfml.RenderTexture.create_with_settings(width: cuint, height: cuint, settings: *sfml.ContextSettings <const>): *sfml.RenderTexture <cimport 'sfRenderTexture_createWithSettings', nodecl> end

function sfml.RenderTexture.destroy(self: *sfml.RenderTexture): void <cimport 'sfRenderTexture_destroy', nodecl> end
function sfml.RenderTexture.get_size(self: *sfml.RenderTexture <const>): sfml.Vector2u <cimport 'sfRenderTexture_getSize', nodecl> end
function sfml.RenderTexture.set_active(self: *sfml.RenderTexture, active: sfml.Bool): sfml.Vector2u <cimport 'sfRenderTexture_setActive', nodecl> end
function sfml.RenderTexture.display(self: *sfml.RenderTexture): void <cimport 'sfRenderTexture_display', nodecl> end
function sfml.RenderTexture.clear(self: *sfml.RenderTexture, color: sfml.Color): void <cimport 'sfRenderTexture_clear', nodecl> end
function sfml.RenderTexture.get_view(self: *sfml.RenderTexture <const>): *sfml.View <cimport 'sfRenderTexture_getView', nodecl> end
function sfml.RenderTexture.set_view(self: *sfml.RenderTexture, view: *sfml.View <const>): void <cimport 'sfRenderTexture_setView', nodecl> end
function sfml.RenderTexture.get_default_view(self: *sfml.RenderTexture <const>): *sfml.View <cimport 'sfRenderTexture_getDefaultView', nodecl> end
function sfml.RenderTexture.get_viewport(self: *sfml.RenderTexture <const>, view: *sfml.View <const>): sfml.IntRect <cimport 'sfRenderTexture_getViewport', nodecl> end
function sfml.RenderTexture.map_pixel_to_coords(self: *sfml.RenderTexture <const>, point: sfml.Vector2i, view: *sfml.View <const>): sfml.Vector2f <cimport 'sfRenderTexture_mapPixelToCoords', nodecl> end
function sfml.RenderTexture.map_coords_to_pixel(self: *sfml.RenderTexture <const>, point: sfml.Vector2f, view: *sfml.View <const>): sfml.Vector2i <cimport 'sfRenderTexture_mapCoordsToPixel', nodecl> end
function sfml.RenderTexture.draw_sprite(self: *sfml.RenderTexture, object: *sfml.Sprite <const>, states: *sfml.RenderStates <const>): void <cimport 'sfRenderTexture_drawSprite', nodecl> end
function sfml.RenderTexture.draw_text(self: *sfml.RenderTexture, object: *sfml.Text <const>, states: *sfml.RenderStates <const>): void <cimport 'sfRenderTexture_drawText', nodecl> end
function sfml.RenderTexture.draw_shape(self: *sfml.RenderTexture, object: *sfml.Shape <const>, states: *sfml.RenderStates <const>): void <cimport 'sfRenderTexture_drawCircleShape', nodecl> end
function sfml.RenderTexture.draw_circle_shape(self: *sfml.RenderTexture, object: *sfml.CircleShape <const>, states: *sfml.RenderStates <const>): void <cimport 'sfRenderTexture_drawCircleShape', nodecl> end
function sfml.RenderTexture.draw_convex_shape(self: *sfml.RenderTexture, object: *sfml.ConvexShape <const>, states: *sfml.RenderStates <const>): void <cimport 'sfRenderTexture_drawConvexShape', nodecl> end
function sfml.RenderTexture.draw_rectangle_shape(self: *sfml.RenderTexture, object: *sfml.RectangleShape <const>, states: *sfml.RenderStates <const>): void <cimport 'sfRenderTexture_drawRectangleShape', nodecl> end
function sfml.RenderTexture.draw_vertex_array(self: *sfml.RenderTexture, object: *sfml.VertexArray <const>, states: *sfml.RenderStates <const>): void <cimport 'sfRenderTexture_drawVertexArray', nodecl> end
function sfml.RenderTexture.draw_vertex_buffer(self: *sfml.RenderTexture, object: *sfml.VertexBuffer <const>, states: *sfml.RenderStates <const>): void <cimport 'sfRenderTexture_drawVertexBuffer', nodecl> end
function sfml.RenderTexture.draw_primitives(self: *sfml.RenderTexture, vertices: *[0]sfml.Vertex <const>, vertexCount: csize, type: sfml.PrimitiveType, states: *sfml.RenderStates <const>): void <cimport 'sfRenderTexture_drawPrimitives', nodecl> end
function sfml.RenderTexture.push_gl_states(self: *sfml.RenderTexture): void <cimport 'sfRenderTexture_pushGLStates', nodecl> end
function sfml.RenderTexture.pop_gl_states(self: *sfml.RenderTexture): void <cimport 'sfRenderTexture_popGLStates', nodecl> end
function sfml.RenderTexture.reset_gl_states(self: *sfml.RenderTexture): void <cimport 'sfRenderTexture_resetGLStates', nodecl> end
function sfml.RenderTexture.get_texture(self: *sfml.RenderTexture <const>): *sfml.Texture <cimport 'sfRenderTexture_getTexture', nodecl> end
function sfml.RenderTexture.get_maximum_antialiasing_level(): cuint <cimport 'sfRenderTexture_getMaximumAntialiasingLevel', nodecl> end
function sfml.RenderTexture.is_smooth(self: *sfml.RenderTexture <const>): sfml.Bool <cimport 'sfRenderTexture_isSmooth', nodecl> end
function sfml.RenderTexture.set_smooth(self: *sfml.RenderTexture, smooth: sfml.Bool): void <cimport 'sfRenderTexture_setSmooth', nodecl> end
function sfml.RenderTexture.is_repeated(self: *sfml.RenderTexture <const>): sfml.Bool <cimport 'sfRenderTexture_isRepeated', nodecl> end
function sfml.RenderTexture.set_repeated(self: *sfml.RenderTexture, repeated: sfml.Bool): void <cimport 'sfRenderTexture_setRepeated', nodecl> end
function sfml.RenderTexture.generate_mipmap(self: *sfml.RenderTexture): sfml.Bool <cimport 'sfRenderTexture_generateMipmap', nodecl> end


-- Render Window
function sfml.RenderWindow.create(mode: sfml.VideoMode, title: cstring <const>, style: sfml.Uint32, settings: *sfml.ContextSettings <const>): *sfml.RenderWindow <cimport 'sfRenderWindow_create', nodecl> end
function sfml.RenderWindow.create_unicode(mode: sfml.VideoMode, title: *sfml.Uint32, style: sfml.Uint32, settings: *sfml.ContextSettings <const>): *sfml.RenderWindow <cimport 'sfRenderWindow_createUnicode', nodecl> end
function sfml.RenderWindow.create_from_handle(handle: sfml.WindowHandle, settings: *sfml.ContextSettings <const>): *sfml.RenderWindow <cimport 'sfRenderWindow_createFromHandle', nodecl> end

function sfml.RenderWindow.destroy(self: *sfml.RenderWindow): void <cimport 'sfRenderWindow_destroy', nodecl> end
function sfml.RenderWindow.close(self: *sfml.RenderWindow): void <cimport 'sfRenderWindow_close', nodecl> end
function sfml.RenderWindow.is_open(self: *sfml.RenderWindow <const>): sfml.Bool <cimport 'sfRenderWindow_isOpen', nodecl> end
function sfml.RenderWindow.get_settings(self: *sfml.RenderWindow <const>): sfml.ContextSettings <cimport 'sfRenderWindow_getSettings', nodecl> end
function sfml.RenderWindow.poll_event(self: *sfml.RenderWindow, event: *sfml.Event): sfml.Bool <cimport 'sfRenderWindow_pollEvent', nodecl> end
function sfml.RenderWindow.wait_event(self: *sfml.RenderWindow, event: *sfml.Event): sfml.Bool <cimport 'sfRenderWindow_waitEvent', nodecl> end
function sfml.RenderWindow.get_position(self: *sfml.RenderWindow <const>): sfml.Vector2i <cimport 'sfRenderWindow_getPosition', nodecl> end
function sfml.RenderWindow.set_position(self: *sfml.RenderWindow, position: sfml.Vector2i): void <cimport 'sfRenderWindow_setPosition', nodecl> end
function sfml.RenderWindow.get_size(self: *sfml.RenderWindow <const>): sfml.Vector2u <cimport 'sfRenderWindow_getSize', nodecl> end
function sfml.RenderWindow.set_size(self: *sfml.RenderWindow, size: sfml.Vector2u): void <cimport 'sfRenderWindow_setSize', nodecl> end
function sfml.RenderWindow.set_unicode_title(self: *sfml.RenderWindow, title: *sfml.Uint32 <const>): void <cimport 'sfRenderWindow_setUnicodeTitle', nodecl> end
function sfml.RenderWindow.set_icon(self: *sfml.RenderWindow, width: cuint, height: cuint, pixels: *[0]sfml.Uint8 <const>): void <cimport 'sfRenderWindow_setIcon', nodecl> end
function sfml.RenderWindow.set_visible(self: *sfml.RenderWindow, visible: sfml.Bool): void <cimport 'sfRenderWindow_setVisible', nodecl> end
function sfml.RenderWindow.set_vsync_enabled(self: *sfml.RenderWindow, enabled: sfml.Bool): void <cimport 'sfRenderWindow_setVerticalSyncEnabled', nodecl> end
function sfml.RenderWindow.set_mouse_cursor_visible(self: *sfml.RenderWindow, show: sfml.Bool): void <cimport 'sfRenderWindow_setMouseCursorVisible', nodecl> end
function sfml.RenderWindow.set_mouse_cursor_grabbed(self: *sfml.RenderWindow, grabbed: sfml.Bool): void <cimport 'sfRenderWindow_setMouseCursorGrabbed', nodecl> end
function sfml.RenderWindow.set_mouse_cursor(self: *sfml.RenderWindow, cursor: *sfml.Cursor <const>): void <cimport 'sfRenderWindow_setMouseCursor', nodecl> end
function sfml.RenderWindow.set_key_repeat_enabled(self: *sfml.RenderWindow, enabled: sfml.Bool): void <cimport 'sfRenderWindow_setKeyRepeatEnabled', nodecl> end
function sfml.RenderWindow.set_framerate_limit(self: *sfml.RenderWindow, limit: cuint): void <cimport 'sfRenderWindow_setFramerateLimit', nodecl> end
function sfml.RenderWindow.set_joystick_threshold(self: *sfml.RenderWindow, threshold: float32): void <cimport 'sfRenderWindow_setJoystickThreshold', nodecl> end
function sfml.RenderWindow.set_active(self: *sfml.RenderWindow, active: sfml.Bool): void <cimport 'sfRenderWindow_setActive', nodecl> end
function sfml.RenderWindow.has_focus(self: *sfml.RenderWindow <const>): sfml.Bool <cimport 'sfRenderWindow_hasFocus', nodecl> end
function sfml.RenderWindow.request_focus(self: *sfml.RenderWindow): void <cimport 'sfRenderWindow_requestFocus', nodecl> end
function sfml.RenderWindow.display(self: *sfml.RenderWindow): void <cimport 'sfRenderWindow_display', nodecl> end
function sfml.RenderWindow.get_system_handle(self: *sfml.RenderWindow <const>): sfml.WindowHandle <cimport 'sfRenderWindow_getSystemHandle', nodecl> end
function sfml.RenderWindow.clear(self: *sfml.RenderWindow, color: sfml.Color): void <cimport 'sfRenderWindow_clear', nodecl> end
function sfml.RenderWindow.get_view(self: *sfml.RenderWindow <const>): *sfml.View <cimport 'sfRenderWindow_getView', nodecl> end
function sfml.RenderWindow.set_view(self: *sfml.RenderWindow, view: *sfml.View): void <cimport 'sfRenderWindow_setView', nodecl> end
function sfml.RenderWindow.get_default_view(self: *sfml.RenderWindow <const>): *sfml.View <cimport 'sfRenderWindow_getDefaultView', nodecl> end
function sfml.RenderWindow.get_viewport(self: *sfml.RenderWindow <const>, view: *sfml.View <const>): sfml.IntRect <cimport 'sfRenderWindow_getViewport', nodecl> end
function sfml.RenderWindow.map_pixel_to_coords(self: *sfml.RenderWindow <const>, point: sfml.Vector2i, view: *sfml.View <const>): sfml.Vector2f <cimport 'sfRenderWindow_mapPixelToCoords', nodecl> end
function sfml.RenderWindow.map_coords_to_pixel(self: *sfml.RenderWindow <const>, point: sfml.Vector2f, view: *sfml.View <const>): sfml.Vector2i <cimport 'sfRenderWindow_mapCoordsToPixel', nodecl> end
function sfml.RenderWindow.draw_sprite(self: *sfml.RenderWindow, object: *sfml.Sprite <const>, states: *sfml.RenderStates <const>): void <cimport 'sfRenderWindow_drawSprite', nodecl> end
function sfml.RenderWindow.draw_text(self: *sfml.RenderWindow, object: *sfml.Text <const>, states: *sfml.RenderStates <const>): void <cimport 'sfRenderWindow_drawText', nodecl> end
function sfml.RenderWindow.draw_shape(self: *sfml.RenderWindow, object: *sfml.Shape <const>, states: *sfml.RenderStates <const>): void <cimport 'sfRenderWindow_drawShape', nodecl> end
function sfml.RenderWindow.draw_circle_shape(self: *sfml.RenderWindow, object: *sfml.CircleShape <const>, states: *sfml.RenderStates <const>): void <cimport 'sfRenderWindow_drawCircleShape', nodecl> end
function sfml.RenderWindow.draw_convex_shape(self: *sfml.RenderWindow, object: *sfml.ConvexShape <const>, states: *sfml.RenderStates <const>): void <cimport 'sfRenderWindow_drawConvexShape', nodecl> end
function sfml.RenderWindow.draw_rectangle_shape(self: *sfml.RenderWindow, object: *sfml.RectangleShape <const>, states: *sfml.RenderStates <const>): void <cimport 'sfRenderWindow_drawRectangleShape', nodecl> end
function sfml.RenderWindow.draw_vertex_array(self: *sfml.RenderWindow, object: *sfml.VertexArray <const>, states: *sfml.RenderStates <const>): void <cimport 'sfRenderWindow_drawVertexArray', nodecl> end
function sfml.RenderWindow.draw_vertex_buffer(self: *sfml.RenderWindow, object: *sfml.VertexBuffer <const>, states: *sfml.RenderStates <const>): void <cimport 'sfRenderWindow_drawVertexBuffer', nodecl> end
function sfml.RenderWindow.draw_primitives(self: *sfml.RenderWindow, vertices: *sfml.Vertex <const>, vertexCount: csize, type: sfml.PrimitiveType, states: *sfml.RenderStates <const>): void <cimport 'sfRenderWindow_drawPrimitives', nodecl> end
function sfml.RenderWindow.push_gl_states(self: *sfml.RenderWindow): void <cimport 'sfRenderWindow_pushGLStates', nodecl> end
function sfml.RenderWindow.pop_gl_states(self: *sfml.RenderWindow): void <cimport 'sfRenderWindow_popGLStates', nodecl> end
function sfml.RenderWindow.reset_gl_states(self: *sfml.RenderWindow): void <cimport 'sfRenderWindow_resetGLStates', nodecl> end
function sfml.RenderWindow.capture(self: *sfml.RenderWindow <const>): *sfml.Image <cimport 'sfRenderWindow_capture', nodecl> end


-- Render Window: Mouse
function sfml.Mouse.get_position_render_window(relativeTo: *sfml.RenderWindow <const>): sfml.Vector2i <cimport 'sfMouse_getPositionRenderWindow', nodecl> end
function sfml.Mouse.set_position_render_window(position: sfml.Vector2i, relativeTo: *sfml.RenderWindow <const>): void <cimport 'sfMouse_setPositionRenderWindow', nodecl> end
function sfml.Touch.get_position_render_window(finger: cuint, relativeTo: *sfml.RenderWindow <const>): sfml.Vector2i <cimport 'sfTouch_getPositionRenderWindow', nodecl> end


-- Shader
function sfml.Shader.create_from_file(vertexShaderFilename: cstring <const>, geometryShaderFilename: cstring <const>, fragmentShaderFilename: cstring <const>): *sfml.Shader <cimport 'sfShader_createFromFile', nodecl> end
function sfml.Shader.create_from_memory(vertexShader: cstring <const>, geometryShader: cstring <const>, fragmentShader: cstring <const>): *sfml.Shader <cimport 'sfShader_createFromMemory', nodecl> end
function sfml.Shader.create_from_stream(vertexShader: *sfml.InputStream, geometryShader: *sfml.InputStream, fragmentShader: *sfml.InputStream): *sfml.Shader <cimport 'sfShader_createFromStream', nodecl> end

function sfml.Shader.destroy(self: *sfml.Shader): void <cimport 'sfShader_destroy', nodecl> end
function sfml.Shader.set_float_uniform(self: *sfml.Shader, name: cstring <const>, x: float32): void <cimport 'sfShader_setFloatUniform', nodecl> end
function sfml.Shader.set_vec3_uniform(self: *sfml.Shader, name: cstring <const>, vector: sfml.GlslVec3): void <cimport 'sfShader_setVec3Uniform', nodecl> end
function sfml.Shader.set_vec4_uniform(self: *sfml.Shader, name: cstring <const>, vector: sfml.GlslVec4): void <cimport 'sfShader_setVec4Uniform', nodecl> end
function sfml.Shader.set_color_uniform(self: *sfml.Shader, name: cstring <const>, color: sfml.Color): void <cimport 'sfShader_setColorUniform', nodecl> end
function sfml.Shader.set_int_uniform(self: *sfml.Shader, name: cstring <const>, x: cint): void <cimport 'sfShader_setIntUniform', nodecl> end
function sfml.Shader.set_ivec2_uniform(self: *sfml.Shader, name: cstring <const>, vector: sfml.GlslIvec2): void <cimport 'sfShader_setIvec2Uniform', nodecl> end
function sfml.Shader.set_ivec3_uniform(self: *sfml.Shader, name: cstring <const>, vector: sfml.GlslIvec3): void <cimport 'sfShader_setIvec3Uniform', nodecl> end
function sfml.Shader.set_ivec4_uniform(self: *sfml.Shader, name: cstring <const>, vector: sfml.GlslIvec4): void <cimport 'sfShader_setIvec4Uniform', nodecl> end
function sfml.Shader.set_int_color_uniform(self: *sfml.Shader, name: cstring <const>, color: sfml.Color): void <cimport 'sfShader_setIntColorUniform', nodecl> end
function sfml.Shader.set_bool_uniform(self: *sfml.Shader, name: cstring <const>, x: sfml.Bool): void <cimport 'sfShader_setBoolUniform', nodecl> end
function sfml.Shader.set_bvec2_uniform(self: *sfml.Shader, name: cstring <const>, vector: sfml.GlslBvec2): void <cimport 'sfShader_setBvec2Uniform', nodecl> end
function sfml.Shader.set_bvec3_uniform(self: *sfml.Shader, name: cstring <const>, vector: sfml.GlslBvec3): void <cimport 'sfShader_setBvec3Uniform', nodecl> end
function sfml.Shader.set_bvec4_uniform(self: *sfml.Shader, name: cstring <const>, vector: sfml.GlslBvec4): void <cimport 'sfShader_setBvec4Uniform', nodecl> end
function sfml.Shader.set_mat3_uniform(self: *sfml.Shader, name: cstring <const>, matrix: *sfml.GlslMat3 <const>): void <cimport 'sfShader_setMat3Uniform', nodecl> end
function sfml.Shader.set_mat4_uniform(self: *sfml.Shader, name: cstring <const>, matrix: *sfml.GlslMat4 <const>): void <cimport 'sfShader_setMat4Uniform', nodecl> end
function sfml.Shader.set_texture_uniform(self: *sfml.Shader, name: cstring <const>, texture: *sfml.Texture <const>): void <cimport 'sfShader_setTextureUniform', nodecl> end
function sfml.Shader.set_current_texture_uniform(self: *sfml.Shader, name: cstring <const>): void <cimport 'sfShader_setCurrentTextureUniform', nodecl> end
function sfml.Shader.set_float_uniform_array(self: *sfml.Shader, name: cstring <const>, scalarArray: *[0]float32, length: csize): void <cimport 'sfShader_setFloatUniformArray', nodecl> end
function sfml.Shader.set_vec2_uniform_array(self: *sfml.Shader, name: cstring <const>, vectorArray: *[0]sfml.GlslVec2, length: csize): void <cimport 'sfShader_setVec2UniformArray', nodecl> end
function sfml.Shader.set_vec3_uniform_array(self: *sfml.Shader, name: cstring <const>, vectorArray: *[0]sfml.GlslVec3, length: csize): void <cimport 'sfShader_setVec3UniformArray', nodecl> end
function sfml.Shader.set_vec4_uniform_array(self: *sfml.Shader, name: cstring <const>, vectorArray: *[0]sfml.GlslVec4, length: csize): void <cimport 'sfShader_setVec4UniformArray', nodecl> end
function sfml.Shader.set_mat3_uniform_array(self: *sfml.Shader, name: cstring <const>, matrixArray: *[0]sfml.GlslMat3, length: csize): void <cimport 'sfShader_setMat3UniformArray', nodecl> end
function sfml.Shader.set_mat4_uniform_array(self: *sfml.Shader, name: cstring <const>, matrixArray: *[0]sfml.GlslMat4, length: csize): void <cimport 'sfShader_setMat4UniformArray', nodecl> end
function sfml.Shader.set_float_parameter(self: *sfml.Shader, name: cstring <const>, x: float32): void <cimport 'sfShader_setFloatParameter', nodecl> end
function sfml.Shader.set_float2_parameter(self: *sfml.Shader, name: cstring <const>, x: float32, y: float32): void <cimport 'sfShader_setFloat2Parameter', nodecl> end
function sfml.Shader.set_float3_parameter(self: *sfml.Shader, name: cstring <const>, x: float32, y: float32, z: float32): void <cimport 'sfShader_setFloat3Parameter', nodecl> end
function sfml.Shader.set_float4_parameter(self: *sfml.Shader, name: cstring <const>, x: float32, y: float32, z: float32, w: float32): void <cimport 'sfShader_setFloat4Parameter', nodecl> end
function sfml.Shader.set_vector2_parameter(self: *sfml.Shader, name: cstring <const>, vector: sfml.Vector2f): void <cimport 'sfShader_setVector2Parameter', nodecl> end
function sfml.Shader.set_vector3_parameter(self: *sfml.Shader, name: cstring <const>, vector: sfml.Vector3f): void <cimport 'sfShader_setVector3Parameter', nodecl> end
function sfml.Shader.set_color_parameter(self: *sfml.Shader, name: cstring <const>, color: sfml.Color): void <cimport 'sfShader_setColorParameter', nodecl> end
function sfml.Shader.set_transform_parameter(self: *sfml.Shader, name: cstring <const>, transform: sfml.Transform): void <cimport 'sfShader_setTransformParameter', nodecl> end
function sfml.Shader.set_texture_parameter(self: *sfml.Shader, name: cstring <const>, texture: *sfml.Texture <const>): void <cimport 'sfShader_setTextureParameter', nodecl> end
function sfml.Shader.set_current_texture_parameter(self: *sfml.Shader, name: cstring <const>): void <cimport 'sfShader_setCurrentTextureParameter', nodecl> end
function sfml.Shader.get_native_handle(self: *sfml.Shader <const>): cuint <cimport 'sfShader_getNativeHandle', nodecl> end
function sfml.Shader.bind(self: *sfml.Shader <const>): void <cimport 'sfShader_bind', nodecl> end

function sfml.Shader.is_available(): sfml.Bool <cimport 'sfShader_isAvailable', nodecl> end
function sfml.Shader.is_geometry_available(): sfml.Bool <cimport 'sfShader_isGeometryAvailable', nodecl> end


-- Shape
global sfml.ShapeGetPointCountCallback: type <cimport 'sfShapeGetPointCountCallback', nodecl> = @function(pointer): csize
global sfml.ShapeGetPointCallback: type <cimport 'sfShapeGetPointCallback', nodecl> = @function(csize, pointer): sfml.Vector2f

function sfml.Shape.create(getPointCount: sfml.ShapeGetPointCountCallback, getPoint: sfml.ShapeGetPointCallback, userData: pointer): *sfml.Shape <cimport 'sfShape_create', nodecl> end

function sfml.Shape.destroy(self: *sfml.Shape): void <cimport 'sfShape_destroy', nodecl> end
function sfml.Shape.get_position(self: *sfml.Shape <const>): sfml.Vector2f <cimport 'sfShape_getPosition', nodecl> end
function sfml.Shape.set_position(self: *sfml.Shape, position: sfml.Vector2f): void <cimport 'sfShape_setPosition', nodecl> end
function sfml.Shape.get_rotation(self: *sfml.Shape <const>): float32 <cimport 'sfShape_getRotation', nodecl> end
function sfml.Shape.set_rotation(self: *sfml.Shape, angle: float32): void <cimport 'sfShape_setRotation', nodecl> end
function sfml.Shape.get_scale(self: *sfml.Shape <const>): sfml.Vector2f <cimport 'sfShape_getScale', nodecl> end
function sfml.Shape.set_scale(self: *sfml.Shape, scale: sfml.Vector2f): void <cimport 'sfShape_setScale', nodecl> end
function sfml.Shape.get_origin(self: *sfml.Shape <const>): sfml.Vector2f <cimport 'sfShape_getOrigin', nodecl> end
function sfml.Shape.set_origin(self: *sfml.Shape, origin: sfml.Vector2f): void <cimport 'sfShape_setOrigin', nodecl> end
function sfml.Shape.get_size(self: *sfml.Shape <const>): sfml.Vector2f <cimport 'sfShape_getSize', nodecl> end
function sfml.Shape.set_size(self: *sfml.Shape, size: float32): void <cimport 'sfShape_setSize', nodecl> end
function sfml.Shape.get_texture(self: *sfml.Shape <const>): *sfml.Texture <cimport 'sfShape_getTexture', nodecl> end
function sfml.Shape.set_texture(self: *sfml.Shape, texture: *sfml.Texture <const>, resetRect: sfml.Bool): void <cimport 'sfShape_setTexture', nodecl> end
function sfml.Shape.get_texture_rect(self: *sfml.Shape <const>): sfml.IntRect <cimport 'sfShape_getTextureRect', nodecl> end
function sfml.Shape.set_texture_rect(self: *sfml.Shape, rect: sfml.IntRect): void <cimport 'sfShape_setTextureRect', nodecl> end
function sfml.Shape.get_fill_color(self: *sfml.Shape <const>): sfml.Color <cimport 'sfShape_getFillColor', nodecl> end
function sfml.Shape.set_fill_color(self: *sfml.Shape, color: sfml.Color): void <cimport 'sfShape_setFillColor', nodecl> end
function sfml.Shape.get_outline_color(self: *sfml.Shape <const>): sfml.Color <cimport 'sfShape_getOutlineColor', nodecl> end
function sfml.Shape.set_outline_color(self: *sfml.Shape, color: sfml.Color): void <cimport 'sfShape_setOutlineColor', nodecl> end
function sfml.Shape.get_outline_thickness(self: *sfml.Shape <const>): float32 <cimport 'sfShape_getOutlineThickness', nodecl> end
function sfml.Shape.set_outline_thickness(self: *sfml.Shape, thickness: float32): void <cimport 'sfShape_setOutlineThickness', nodecl> end
function sfml.Shape.get_point_count(self: *sfml.Shape <const>): csize <cimport 'sfShape_getPointCount', nodecl> end
function sfml.Shape.set_point_count(self: *sfml.Shape, count: csize): void <cimport 'sfShape_setPointCount', nodecl> end
function sfml.Shape.move(self: *sfml.Shape, offset: sfml.Vector2f): void <cimport 'sfShape_move', nodecl> end
function sfml.Shape.rotate(self: *sfml.Shape, angle: float32): void <cimport 'sfShape_rotate', nodecl> end
function sfml.Shape.scale(self: *sfml.Shape, factors: sfml.Vector2f): void <cimport 'sfShape_scale', nodecl> end
function sfml.Shape.get_transform(self: *sfml.Shape <const>): sfml.Transform <cimport 'sfShape_getTransform', nodecl> end
function sfml.Shape.get_inverse_transform(self: *sfml.Shape <const>): sfml.Transform <cimport 'sfShape_getInverseTransform', nodecl> end
function sfml.Shape.get_point(self: *sfml.Shape <const>, index: csize): sfml.Vector2f <cimport 'sfShape_getPoint', nodecl> end
function sfml.Shape.get_local_bounds(self: *sfml.Shape <const>): sfml.FloatRect <cimport 'sfShape_getLocalBounds', nodecl> end
function sfml.Shape.get_global_bounds(self: *sfml.Shape <const>): sfml.FloatRect <cimport 'sfShape_getGlobalBounds', nodecl> end
function sfml.Shape.update(self: *sfml.Shape): void <cimport 'sfShape_update', nodecl> end


-- Sprite
function sfml.Sprite.create(): *sfml.Sprite <cimport 'sfSprite_create', nodecl> end

function sfml.Sprite.copy(self: *sfml.Sprite <const>): *sfml.Sprite <cimport 'sfSprite_copy', nodecl> end
function sfml.Sprite.destroy(self: *sfml.Sprite): void <cimport 'sfSprite_destroy', nodecl> end
function sfml.Sprite.get_position(self: *sfml.Sprite <const>): sfml.Vector2f <cimport 'sfSprite_getPosition', nodecl> end
function sfml.Sprite.set_position(self: *sfml.Sprite, position: sfml.Vector2f): void <cimport 'sfSprite_setPosition', nodecl> end
function sfml.Sprite.get_rotation(self: *sfml.Sprite <const>): float32 <cimport 'sfSprite_getRotation', nodecl> end
function sfml.Sprite.set_rotation(self: *sfml.Sprite, angle: float32): void <cimport 'sfSprite_setRotation', nodecl> end
function sfml.Sprite.get_scale(self: *sfml.Sprite <const>): sfml.Vector2f <cimport 'sfSprite_getScale', nodecl> end
function sfml.Sprite.set_scale(self: *sfml.Sprite, scale: sfml.Vector2f): void <cimport 'sfSprite_setScale', nodecl> end
function sfml.Sprite.get_origin(self: *sfml.Sprite <const>): sfml.Vector2f <cimport 'sfSprite_getOrigin', nodecl> end
function sfml.Sprite.set_origin(self: *sfml.Sprite, origin: sfml.Vector2f): void <cimport 'sfSprite_setOrigin', nodecl> end
function sfml.Sprite.get_texture(self: *sfml.Sprite <const>): *sfml.Texture <cimport 'sfSprite_getTexture', nodecl> end
function sfml.Sprite.set_texture(self: *sfml.Sprite, texture: *sfml.Texture, resetRect: sfml.Bool): void <cimport 'sfSprite_setTexture', nodecl> end
function sfml.Sprite.get_texture_rect(self: *sfml.Sprite <const>): sfml.IntRect <cimport 'sfSprite_getTextureRect', nodecl> end
function sfml.Sprite.set_texture_rect(self: *sfml.Sprite, rectangle: sfml.IntRect): void <cimport 'sfSprite_setTextureRect', nodecl> end
function sfml.Sprite.get_color(self: *sfml.Sprite <const>): sfml.Color <cimport 'sfSprite_getColor', nodecl> end
function sfml.Sprite.set_color(self: *sfml.Sprite, color: sfml.Color): void <cimport 'sfSprite_setColor', nodecl> end
function sfml.Sprite.move(self: *sfml.Sprite, offset: sfml.Vector2f): void <cimport 'sfSprite_move', nodecl> end
function sfml.Sprite.rotate(self: *sfml.Sprite, angle: float32): void <cimport 'sfSprite_rotate', nodecl> end
function sfml.Sprite.scale(self: *sfml.Sprite, factors: sfml.Vector2f): void <cimport 'sfSprite_scale', nodecl> end
function sfml.Sprite.get_transform(self: *sfml.Sprite <const>): sfml.Transform <cimport 'sfSprite_getTransform', nodecl> end
function sfml.Sprite.get_inverse_transform(self: *sfml.Sprite <const>): sfml.Transform <cimport 'sfSprite_getInverseTransform', nodecl> end
function sfml.Sprite.get_local_bounds(self: *sfml.Sprite <const>): sfml.FloatRect <cimport 'sfSprite_getLocalBounds', nodecl> end
function sfml.Sprite.get_global_bounds(self: *sfml.Sprite <const>): sfml.FloatRect <cimport 'sfSprite_getGlobalBounds', nodecl> end


-- Text
global sfml.TextStyle: type <cimport 'sfTextStyle', nodecl, using> = @enum(cint) {
  Regular       = 0,
  Bold          = 1 << 0,
  Italic        = 1 << 1,
  Underlined    = 1 << 2,
  StrikeThrough = 1 << 3
}

function sfml.Text.create(): *sfml.Text <cimport 'sfText_create', nodecl> end

function sfml.Text.copy(self: *sfml.Text <const>): *sfml.Text <cimport 'sfText_copy', nodecl> end
function sfml.Text.destroy(self: *sfml.Text): void <cimport 'sfText_destroy', nodecl> end
function sfml.Text.get_position(self: *sfml.Text <const>): sfml.Vector2f <cimport 'sfText_getPosition', nodecl> end
function sfml.Text.set_position(self: *sfml.Text, position: sfml.Vector2f): void <cimport 'sfText_setPosition', nodecl> end
function sfml.Text.get_rotation(self: *sfml.Text <const>): float32 <cimport 'sfText_getRotation', nodecl> end
function sfml.Text.set_rotation(self: *sfml.Text, angle: float32): void <cimport 'sfText_setRotation', nodecl> end
function sfml.Text.get_scale(self: *sfml.Text <const>): sfml.Vector2f <cimport 'sfText_getScale', nodecl> end
function sfml.Text.set_scale(self: *sfml.Text, scale: sfml.Vector2f): void <cimport 'sfText_setScale', nodecl> end
function sfml.Text.get_origin(self: *sfml.Text <const>): sfml.Vector2f <cimport 'sfText_getOrigin', nodecl> end
function sfml.Text.set_origin(self: *sfml.Text, origin: sfml.Vector2f): void <cimport 'sfText_setOrigin', nodecl> end
function sfml.Text.get_string(self: *sfml.Text <const>): cstring <cimport 'sfText_getString', nodecl> end
function sfml.Text.set_string(self: *sfml.Text, string: cstring <const>): void <cimport 'sfText_setString', nodecl> end
function sfml.Text.get_unicod_string(self: *sfml.Text <const>): *sfml.Uint32 <cimport 'sfText_getUnicodeString', nodecl> end
function sfml.Text.set_unicod_string(self: *sfml.Text, string: *sfml.Uint32 <const>): void <cimport 'sfText_setUnicodeString', nodecl> end
function sfml.Text.get_font(self: *sfml.Text <const>): *sfml.Font <cimport 'sfText_getFont', nodecl> end
function sfml.Text.set_font(self: *sfml.Text, font: *sfml.Font <const>): void <cimport 'sfText_setFont', nodecl> end
function sfml.Text.get_character_size(self: *sfml.Text <const>): cuint <cimport 'sfText_getCharacterSize', nodecl> end
function sfml.Text.set_character_size(self: *sfml.Text, size: cuint): void <cimport 'sfText_setCharacterSize', nodecl> end
function sfml.Text.get_line_spacing(self: *sfml.Text <const>): float32 <cimport 'sfText_getLineSpacing', nodecl> end
function sfml.Text.set_line_spacing(self: *sfml.Text, spacingFactor: float32): void <cimport 'sfText_setLineSpacing', nodecl> end
function sfml.Text.get_letter_spacing(self: *sfml.Text <const>): float32 <cimport 'sfText_getLetterSpacing', nodecl> end
function sfml.Text.set_letter_spacing(self: *sfml.Text, spacingFactor: float32): void <cimport 'sfText_setLetterSpacing', nodecl> end
function sfml.Text.get_style(self: *sfml.Text <const>): sfml.Uint32 <cimport 'sfText_getStyle', nodecl> end
function sfml.Text.set_style(self: *sfml.Text, style: sfml.Uint32): void <cimport 'sfText_setStyle', nodecl> end
function sfml.Text.get_color(self: *sfml.Text <const>): sfml.Color <cimport 'sfText_getColor', nodecl> end
function sfml.Text.set_color(self: *sfml.Text, color: sfml.Color): void <cimport 'sfText_setColor', nodecl> end
function sfml.Text.get_fill_color(self: *sfml.Text <const>): sfml.Color <cimport 'sfText_getFillColor', nodecl> end
function sfml.Text.set_fill_color(self: *sfml.Text, color: sfml.Color): void <cimport 'sfText_setFillColor', nodecl> end
function sfml.Text.get_outline_color(self: *sfml.Text <const>): sfml.Color <cimport 'sfText_getOutlineColor', nodecl> end
function sfml.Text.set_outline_color(self: *sfml.Text, color: sfml.Color): void <cimport 'sfText_setOutlineColor', nodecl> end
function sfml.Text.get_outline_thickness(self: *sfml.Text <const>): float32 <cimport 'sfText_getOutlineThickness', nodecl> end
function sfml.Text.set_outline_thickness(self: *sfml.Text, thickness: float32): void <cimport 'sfText_setOutlineThickness', nodecl> end
function sfml.Text.move(self: *sfml.Text, offset: sfml.Vector2f): void <cimport 'sfText_move', nodecl> end
function sfml.Text.rotate(self: *sfml.Text, angle: float32): void <cimport 'sfText_rotate', nodecl> end
function sfml.Text.scale(self: *sfml.Text, factors: sfml.Vector2f): void <cimport 'sfText_scale', nodecl> end
function sfml.Text.get_transform(self: *sfml.Text <const>): sfml.Transform <cimport 'sfText_getTransform', nodecl> end
function sfml.Text.get_inverse_transform(self: *sfml.Text <const>): sfml.Transform <cimport 'sfText_getInverseTransform', nodecl> end

function sfml.Text.find_character_pos(text: cstring <const>, index: csize): sfml.Vector2f <cimport 'sfText_findCharacterPos', nodecl> end
function sfml.Text.get_local_bounds(text: cstring <const>): sfml.FloatRect <cimport 'sfText_getLocalBounds', nodecl> end
function sfml.Text.get_global_bounds(text: cstring <const>): sfml.FloatRect <cimport '', nodecl> end


-- Texture
function sfml.Texture.create(width: cuint, height: cuint): *sfml.Texture <cimport 'sfTexture_create', nodecl> end
function sfml.Texture.create_from_file(filename: cstring <const>, area: *sfml.IntRect <const>): *sfml.Texture <cimport 'sfTexture_createFromFile', nodecl> end
function sfml.Texture.create_from_memory(data: pointer <const>, sizeInBytes: csize, area: *sfml.IntRect <const>): *sfml.Texture <cimport 'sfTexture_createFromMemory', nodecl> end
function sfml.Texture.create_from_stream(stream: *sfml.InputStream, area: *sfml.IntRect <const>): *sfml.Texture <cimport 'sfTexture_createFromStream', nodecl> end
function sfml.Texture.create_from_image(image: *sfml.Image <const>, area: *sfml.IntRect <const>): *sfml.Texture <cimport 'sfTexture_createFromImage', nodecl> end

function sfml.Texture.copy(self: *sfml.Texture <const>): *sfml.Texture <cimport 'sfTexture_copy', nodecl> end
function sfml.Texture.destroy(self: *sfml.Texture): void <cimport 'sfTexture_destroy', nodecl> end
function sfml.Texture.getSize(self: *sfml.Texture <const>): sfml.Vector2u <cimport 'sfTexture_getSize', nodecl> end
function sfml.Texture.copy_to_image(self: *sfml.Texture <const>): *sfml.Image <cimport 'sfTexture_copyToImage', nodecl> end
function sfml.Texture.update_from_pixels(self: *sfml.Texture, pixels: *[0]sfml.Uint8 <const>, width: cuint, height: cuint, x: cuint, y: cuint): void <cimport 'sfTexture_updateFromPixels', nodecl> end
function sfml.Texture.update_from_image(self: *sfml.Texture, source: *sfml.Texture, x: cuint, y: cuint): void <cimport 'sfTexture_updateFromImage', nodecl> end
function sfml.Texture.update_from_window(self: *sfml.Texture, window: *sfml.Window <const>, x: cuint, y: cuint): void <cimport 'sfTexture_updateFromWindow', nodecl> end
function sfml.Texture.update_from_render_window(self: *sfml.Texture, renderWindow: *sfml.RenderWindow <const>, x: cuint, y: cuint): void <cimport 'sfTexture_updateFromRenderWindow', nodecl> end
function sfml.Texture.is_smooth(self: *sfml.Texture <const>): sfml.Bool <cimport 'sfTexture_isSmooth', nodecl> end
function sfml.Texture.set_smooth(self: *sfml.Texture, smooth: sfml.Bool): void <cimport 'sfTexture_setSmooth', nodecl> end
function sfml.Texture.is_srgb(self: *sfml.Texture <const>): sfml.Bool <cimport 'sfTexture_isSrgb', nodecl> end
function sfml.Texture.set_srgb(self: *sfml.Texture, sRgb: sfml.Bool): void <cimport 'sfTexture_setSrgb', nodecl> end
function sfml.Texture.is_repeated(self: *sfml.Texture <const>): sfml.Bool <cimport 'sfTexture_isRepeated', nodecl> end
function sfml.Texture.set_repeated(self: *sfml.Texture, repeated: sfml.Bool): void <cimport 'sfTexture_setRepeated', nodecl> end
function sfml.Texture.generate_mipmap(self: *sfml.Texture): sfml.Bool <cimport 'sfTexture_generateMipmap', nodecl> end
function sfml.Texture.swap(self: *sfml.Texture, right: *sfml.Texture): void <cimport 'sfTexture_swap', nodecl> end
function sfml.Texture.get_native_handle(self: *sfml.Texture <const>): cuint <cimport 'sfTexture_getNativeHandle', nodecl> end
function sfml.Texture.get_maximum_size(): cuint <cimport 'sfTexture_getMaximumSize', nodecl> end


-- Vertex Buffer
global sfml.VertexBufferUsage: type <cimport 'sfVertexBufferUsage', nodecl, using> = @enum(cint) {
  Stream = 0,
  Dynamic,
  Static
}

function sfml.VertexBuffer.create(vertexCount: cuint, type: sfml.PrimitiveType, usage: sfml.VertexBufferUsage): *sfml.VertexBuffer <cimport 'sfVertexBuffer_create', nodecl> end

function sfml.VertexBuffer.copy(self: *sfml.VertexBuffer <const>): *sfml.VertexBuffer <cimport 'sfVertexBuffer_copy', nodecl> end
function sfml.VertexBuffer.destroy(self: *sfml.VertexBuffer): void <cimport 'sfVertexBuffer_destroy', nodecl> end
function sfml.VertexBuffer.get_vertex_count(self: *sfml.VertexBuffer <const>): cuint <cimport 'sfVertexBuffer_getVertexCount', nodecl> end
function sfml.VertexBuffer.update(self: *sfml.VertexBuffer , vertices: *[0]sfml.Vertex <const>, vertexCount: cuint, offset: cuint): sfml.Bool <cimport 'sfVertexBuffer_update', nodecl> end
function sfml.VertexBuffer.update_from_vertex_buffer(self: *sfml.VertexBuffer, other: *sfml.VertexBuffer <const>): sfml.Bool <cimport 'sfVertexBuffer_updateFromVertexBuffer', nodecl> end
function sfml.VertexBuffer.swap(self: *sfml.VertexBuffer, right: *sfml.VertexBuffer): void <cimport 'sfVertexBuffer_swap', nodecl> end
function sfml.VertexBuffer.get_native_handle(self: *sfml.VertexBuffer): cuint <cimport 'sfVertexBuffer_getNativeHandle', nodecl> end
function sfml.VertexBuffer.get_primitive_type(self: *sfml.VertexBuffer <const>): sfml.PrimitiveType <cimport 'sfVertexBuffer_getPrimitiveType', nodecl> end
function sfml.VertexBuffer.set_primitive_type(self: *sfml.VertexBuffer, type: sfml.PrimitiveType): void <cimport 'sfVertexBuffer_setPrimitiveType', nodecl> end
function sfml.VertexBuffer.get_usage(self: *sfml.VertexBuffer <const>): sfml.VertexBufferUsage <cimport 'sfVertexBuffer_getUsage', nodecl> end
function sfml.VertexBuffer.set_usage(self: *sfml.VertexBuffer, usage: sfml.VertexBufferUsage): void <cimport 'sfVertexBuffer_setUsage', nodecl> end
function sfml.VertexBuffer.bind(self: *sfml.VertexBuffer <const>): void <cimport 'sfVertexBuffer_bind', nodecl> end

function sfml.VertexBuffer.is_available(): sfml.Bool <cimport 'sfVertexBuffer_isAvailable', nodecl> end